---
title: 前端面试复习计划之网络
date: 2020-10-1
tags: 
    - 网络
categories: 面试
keywords: [面试]
description: 前端面试复习计划
top_img: # 除非特定需要，可以不写
comments: # 是否显示评论 除非设置false,可以不写
cover: https://s3.bmp.ovh/imgs/2022/11/02/aa3441b06b937568.jpeg # 缩略图
toc: # 章节目录 除非特定文章设置，可以不写
toc_number: # 是否显示toc数字 除非特定文章设置，可以不写
copyright: # 是否显示版权 除非特定文章设置，可以不写
---


## HTTP 基本概念

互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。


## HTTP 工作原理

HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。客户端向服务器发送一个请求报文，服务器以一个状态行作为响应。


## HTTP请求/响应步骤

- 客户端连接到Web服务器
- 发送HTTP请求
- 服务器接受请求并返回HTTP响应
- 释放TCP连接
- 客户端解析HTML内容


## GET与POST区别

- 安全性：GET参数通过URL传递会暴露、不安全，而POST放在RequestBody中，相对更安全
- 针对数据操作的类型不同：GET对数据进行查询，POST主要对数据进行增删改，GET是读，POST是改
- 参数大小不同：GET请求在URL中传达的参数是有长度限制，而POST没有限制
- 浏览器回退表现不同：GET在浏览器回退时是无害的，而POST会再次提交请求
- 浏览器对请求地址的处理不同：GET请求地址会被浏览器主动缓存，而POST不会，除非手动设置
- 浏览器对响应的处理不同：GET请求参数会被完整的保留在历览器历史记录里，而POST中的参数不会被保留


## HTTPS的基本概念

- HTTPS是以安全为目的HTTP通道，即HTTP下加入SSL层进行加密。
- HTTPS协议作用：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。


## HTTP和HTTPS的区别

- HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议
- HTTPS 协议需要 ca 证书，费用较高。
- 使用不同的链接方式，端口也不同，一般，HTTP 协议的端口为 80，HTTPS 的端口为 443。
- HTTP 的连接很简单，是无状态的。


## 客户端HTTPS与Web服务器通信时的步骤

- 客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。
- web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。
- 客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。
- 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。
- web 服务器通过自己的私钥解密出会话密钥。
- web 服务器通过会话密钥加密与客户端之间的通信。


## HTTPS协议的优缺点

- HTTPS 协议要比 http 协议安全，可防止数据在传输过程中被窃取、改变，确保数据的完整性。
- https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。
- https 缓存不如 http 高效，会增加数据开销。
- SSL 证书也需要钱，功能越强大的证书费用越高。
- SSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。


## 什么是TCP/IP网络模型

TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。

- 链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。
- 网络层：负责路由以及把分组报文发送给目标网络或主机。
- 传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。
- 应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。


## TCP三次握手

握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。

- 【你好，我想和你聊一聊？】第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
- 【好的，我有空。】第二次握手：服务器收到syn包并确认客户的SYN（ack=j+1），同时也发送一个自己的SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
- 【好的，我们开始吧。】第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。


## TCP四次挥手

- 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
- 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
- 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。
- 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
- 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
- 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。


## TCP和UDP的区别

- TCP是面向连接的，而UDP是面向无连接的。
- TCP仅支持单播传输，UDP 提供了单播，多播，广播的功能。
- TCP的三次握手保证了连接的可靠性; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。
- UDP的头部开销比TCP的更小，数据传输速率更高，实时性更好。


## HTTP 请求跨域问题

- 跨域的原理
    - 跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的。
    - 同源策略,是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，都被当作是不同的域。
    - 跨域原理，即是通过各种方式，避开浏览器的安全限制。

- 解决方案
    最初使用的是jsonp，但存在一些问题，使用get请求不安全，携带数据较小，后来也用过iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和proxy代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用proxy，在服务器上使用nginx代理，这样开发过程中彼此都方便，效率也高；现在h5新特性还有 windows.postMessage()。

    - JSONP：
    ```
        原理：

        ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，
        利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。

        步骤：
        
        1 去创建一个script标签
        2 script的src属性设置接口地址
        3 接口参数，必须要带一个自定义函数名，要不然后台无法返回数据
        4 通过定义函数名去接受返回的数据
        5 缺点：JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。

        //动态创建 script
        var script = document.createElement('script');

        // 设置回调函数
        function getData(data) {
            console.log(data);
        }

        //设置 script 的 src 属性，并设置请求地址
        script.src = 'http://localhost:3000/?callback=getData';

        // 让 script 生效
        document.body.appendChild(script);
    ```
    - document.domain 基础域名相同 子域名不同。
    - window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name。
    - CORS 跨域资源共享 是一种机制，是目前主流的跨域解决方案，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求。
    - proxy代理 目前常用方式。
    - window.postMessage() 利用h5新特性 window.postMessage()。
    - Websocket。


## Cookie、sessionStorage、localStorage 的区别

**相同点：**

- 存储在客户端

**不同点：**

- cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+
- cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除
- cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地


## HTTP状态码及常见状态码

**HTTP状态码**

- 1xx：指示信息类，表示请求已接受，继续处理
- 2xx：指示成功类，表示请求已成功接受
- 3xx：指示重定向，表示要完成请求必须进行更近一步的操作
- 4xx：指示客户端错误，请求有语法错误或请求无法实现
- 5xx：指示服务器错误，服务器未能实现合法的请求

**常见状态码**

2xx（成功）表示成功处理了请求的状态码

- 200 - 成功 服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页

3xx（重定向）表示要完成请求，需要进一步操作；通常，这些状态代码用来重定向

- 301 - 永久移动 请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置
- 304 - 未修改 自上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容

4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理

- 401 - 未授权 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应
- 403 - 禁止 服务器拒绝请求
- 404 - 未找到 服务器找不到请求的网页

5xx（服务器错误）这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错

- 500 - 服务器内部错误 服务器遇到错误，无法完成请求
- 501 - 尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码
- 502 - 错误网关 服务器作为网关或代理，从上游服务器无法收到无效响应
- 503 - 服务器不可用 服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态
- 504 - 网关超时 服务器作为网关代理，但是没有及时从上游服务器收到请求


## 浏览器的缓存机制 强制缓存 && 协商缓存


## 客户端与服务端长连接的几种方式

- ajax 轮询
    - ajax 轮询指客户端每间隔一段时间向服务端发起请求，保持数据的同步。
    - 优点：可实现基础（指间隔时间较短）的数据更新。
    - 缺点：这种方法也只是尽量的模拟即时传输，但并非真正意义上的即时通讯，很有可能出现客户端请求时，服务端数据并未更新。或者服务端数据已更新，但客户端未发起请求。导致多次请求资源浪费，效率低下。
- long poll 长轮询
    - 实现原理： long poll 指的是客户端发送请求之后，如果没有数据返回，服务端会将请求挂起放入队列（不断开连接）处理其他请求，直到有数据返回给客户端。然后客户端再次发起请求，以此轮询。在 HTTP1.0 中客户端可以设置请求头 Connection:keep-alive，服务端收到该请求头之后知道这是一个长连接，在响应报文头中也添加 Connection:keep-alive。客户端收到之后表示长连接建立完成，可以继续发送其他的请求。在 HTTP1.1 中默认使用了 Connection:keep-alive 长连接。
    - 优点：减少客户端的请求，降低无效的网络传输，保证每次请求都有数据返回，不会一直占用线程。
    - 缺点：无法处理高并发，当客户端请求量大，请求频繁时对服务器的处理能力要求较高。服务器一直保持连接会消耗资源，需要同时维护多个线程，服务器所能承载的 TCP 连接数是有上限的，这种轮询很容易把连接数顶满。每次通讯都需要客户端发起，服务端不能主动推送。
- iframe 长连接
    - 实现原理：在网页上嵌入一个 iframe 标签，该标签的 src 属性指向一个长连接请求。这样服务端就可以源源不断地给客户端传输信息。保障信息实时更新。
    - 优点：消息及时传输。
    - 缺点：消耗服务器资源。
- WebSocket
    - 实现原理： Websocket 实现了客户端与服务端的双向通信，只需要连接一次，就可以相互传输数据，很适合实时通讯、数据实时更新等场景。
    -  Websocket 协议与 HTTP 协议没有关系，它是一个建立在 TCP 协议上的全新协议，为了兼容 HTTP 握手规范，在握手阶段依然使用 HTTP 协议，握手完成之后，数据通过 TCP 通道进行传输。
    - Websoket 数据传输是通过 frame 形式，一个消息可以分成几个片段传输。这样大数据可以分成一些小片段进行传输，不用考虑由于数据量大导致标志位不够的情况。也可以边生成数据边传递消息，提高传输效率。
    - 优点： 双向通信。客户端和服务端双方都可以主动发起通讯。 没有同源限制。客户端可以与任意服务端通信，不存在跨域问题。 数据量轻。第一次连接时需要携带请求头，后面数据通信都不需要带请求头，减少了请求头的负荷。 传输效率高。因为只需要一次连接，所以数据传输效率高。
    - 缺点：需要后端代码稳定，受网络限制大，兼容性差，维护成本高，生态圈小。


## 利用Socket建立网络连接的步骤


## 非对称加密RSA

- 非对称加密算法需要两个密钥：公开密钥(publickey) 和私有密(privatekey) 。
- 与对称加密算法的对比：对称加密只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。非对称加密有两种密钥，其中一个是公开的。
- RSA应用场景：由于RSA算法的加密解密速度要比对称算法速度慢很多，在实际应用中，通常采取数据本身的加密和解密使用对称加密算法(AES)。 用RSA算法加密并传输对称算法所需的密钥。


## HTTP1、HTTP2、HTTP3

HTTP/2 相比于 HTTP/1.1，可以说是大幅度提高了网页的性能，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，虽如此但HTTP/2并非完美的，HTTP/3 就是为了解决 HTTP/2 所存在的一些问题而被推出来的。





<br />
<br />
<br />
<br />
