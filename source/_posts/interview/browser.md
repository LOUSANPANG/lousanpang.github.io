---
title: 浏览器篇
date: 2019-08-26
tags: 
    - 面试篇
categories: 面试篇
keywords: [面试篇]
description: 面试篇
top_img: # 除非特定需要，可以不写
comments: # 是否显示评论 除非设置false,可以不写
cover: https://s3.bmp.ovh/imgs/2021/08/1494536aee1b390e.png # 缩略图
toc: # 章节目录 除非特定文章设置，可以不写
toc_number: # 是否显示toc数字 除非特定文章设置，可以不写
copyright: # 是否显示版权 除非特定文章设置，可以不写
---

### 浏览器加载页面过程
```js
[客户端想服务端发请求数据返回]

输入url回车
|
URI解析 解析出浏览器认识的url
|  --->  DNS服务器  <---  DNS解析
TCP三次握手，建立客户端和服务器端的连接通道
发送HTTP请求
|
服务器端  <---  通过外网IP找到
|
服务器处理和响应
|
TCP的四次挥手，关闭客户端和服务器端的服务通道
|
浏览器解析渲染
```


### 根据 `CRP` 进行性能优化（关键路径渲染）
**浏览器渲染解析流程**

1. 构建DOM树
    ```js
    转换编译  <---  字节码转码成浏览器认识的标签字符集
    |
    令牌  <---  通过W3C规范生成一些 <起始标签> </结束标签> 令牌
    |
    Nodes  <---  通过词法解析生成具体的标记结构，这个时候已经生成结构文档（层级关系）
    |
    DOM  <---  生成一个有标签有结构有层级这样一个树形DOM结构
    ```

优化点：
* 标签语义化。
* 避免深层嵌套（尽保持三四级）。


2. CSSOM数
    ```js
    link @import基于HTTP请求拿回来的字节编码（style不发送http请求）
    
    与构建DOM树构建流程大同小异
    ```

优化点：
* 选择器层级问题（选择器渲染从右向左）。
* 使用预编译器的时候，层级嵌套慎用。


3. Render-Tree渲染树
    ```js
    将DOM树和CSS树融合成渲染树

    根据他们生成的渲染树，计算他们在设备视口内准确位置和大小，这个计算的阶段就是回流（layout）或重排（reflow）

    根据渲染树以及回流信息得到的几何信息，得到节点的绝对像素绘制（painting）或栅格化（rasterizing）
    ```

优化点：
* 真正渲染到页面的时候一定发生在DOMTree和CSSOM树都已经完成了，才可以进行回流和绘制。
* 主线程都是自上而下去解析，每一个HTTP请求都是单线程去渲染。
* DOM树优先于CSSOM树渲染。
* @import也是发送HTTP请求但是同步的，link是异步的请求。
* 真实项目中应减少@import请求。
* 所以说为什么要把link放在顶部（优先下载css）。
* style是根据html一起拿回来的。


DNS解析


缓存




<br>
<br>
<br>
<br>
<br>