<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端面试复习计划之TypeScript</title>
      <link href="/2022/10/01/interview/typescript/"/>
      <url>/2022/10/01/interview/typescript/</url>
      
        <content type="html"><![CDATA[<h2 id="实用技巧关键字"><a href="#实用技巧关键字" class="headerlink" title="实用技巧关键字"></a>实用技巧关键字</h2><p><strong>typeof</strong> 获取一个变量的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Data</span> = <span class="keyword">typeof</span> xx</span><br></pre></td></tr></table></figure><p><strong>keyof</strong> 用来取得一个对象接口的所有key值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span> | <span class="string">&quot;female&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//type PersonKey = &#x27;name&#x27;|&#x27;age&#x27;|&#x27;gender&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonKey</span> = keyof <span class="title class_">Person</span></span><br></pre></td></tr></table></figure><p><strong>in</strong> 去批量定义类型中的属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span> | <span class="string">&quot;female&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//批量把一个接口中的属性都变成可选的</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartPerson</span> = &#123;</span><br><span class="line">  [<span class="title class_">Key</span> <span class="keyword">in</span> keyof <span class="title class_">Person</span>]?: <span class="title class_">Person</span>[<span class="title class_">Key</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>abstract</strong> 抽象类</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类不能用来创建对象，只能专门用来被继承类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个抽象方法</span></span><br><span class="line">  <span class="comment">// 不需要方法体，子类继承后必须实现该抽象方法</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">say</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Aniaml</span>(<span class="string">&#x27;Mike&#x27;</span>) <span class="comment">// error</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Mike&#x27;</span>) <span class="comment">// success</span></span><br></pre></td></tr></table></figure><p><strong>implements</strong> 使类满足接口要求</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInter</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">say</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">MyInter</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>public protected private getter setter</strong> 类的属性修饰符</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 任意关系访问和修改</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 仅类及类的子类可访问修改</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">like</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 仅类内部访问和修改</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下边这种方式是定义加复制的简写</span></span><br><span class="line">  <span class="comment">// 等于 this.paramA = paramA</span></span><br><span class="line">  <span class="title function_">constrctor</span>(<span class="params"><span class="keyword">public</span> paramA: <span class="built_in">string</span>, <span class="keyword">protected</span> paramB: <span class="built_in">string</span>, <span class="keyword">private</span> paramC: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// new Person().name</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// new Person().name = &#x27;Mike&#x27;</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内置工具类型"><a href="#内置工具类型" class="headerlink" title="内置工具类型"></a>内置工具类型</h2><p><strong>Exclude&lt;T,U&gt;</strong> 从T可分配给的类型中排除U</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Exclude</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> E = <span class="title class_">Exclude</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">e</span>: E = <span class="number">10</span> <span class="comment">// 符合条件的只有number</span></span><br></pre></td></tr></table></figure><p><strong>Extract&lt;T,U&gt;</strong> 从T可分配给的类型中提取U</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Extract</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> E = <span class="title class_">Extract</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">e</span>: E = <span class="string">&quot;1&quot;</span> <span class="comment">// 符合条件的只有string</span></span><br></pre></td></tr></table></figure><p><strong>NonNullable<T></strong> 从T中排除null和undefined</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NonNullable</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="literal">null</span> | <span class="literal">undefined</span> ? <span class="built_in">never</span> : T</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> E = <span class="title class_">NonNullable</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">null</span> | <span class="literal">undefined</span>&gt;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">e</span>: E = <span class="number">1</span> <span class="comment">// 符合条件的只有 string | number</span></span><br></pre></td></tr></table></figure><p><strong>infer</strong> 声明一个类型变量并且对它进行使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; infer R ? R : <span class="built_in">any</span></span><br></pre></td></tr></table></figure><p><strong>ReturnType</strong> 表示在extends条件语句中待推断的类型变量</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...<span class="attr">args</span>: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUserInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&quot;hello&quot;</span>, <span class="attr">age</span>: <span class="number">10</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过 ReturnType 将 getUserInfo 的返回值类型赋给了 UserInfo</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> getUserInfo&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">userA</span>: <span class="title class_">UserInfo</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong> 获取函数类型的参数类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Parameters</span>&lt;T&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer R) =&gt; <span class="built_in">any</span> ? R : <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">Parameters</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Parameters</span>&lt;<span class="function">(<span class="params">s: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt; <span class="comment">// [string]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Parameters</span>&lt;&lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T&gt; <span class="comment">// [unknown]</span></span><br></pre></td></tr></table></figure><p><strong>Partial</strong> 将传入的属性由非可选变为可选</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]?: T[P] &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">a1</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">a2</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">a3</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> aPartial = <span class="title class_">Partial</span>&lt;A&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: aPartial = &#123;&#125; <span class="comment">// 不会报错</span></span><br></pre></td></tr></table></figure><p><strong>Required</strong> 将传入的属性中的可选项变为必选项</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Required</span>&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]-?: T[P] &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="string">&quot;male&quot;</span> | <span class="string">&quot;female&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">Required</span>&lt;<span class="title class_">Person</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Readonly</strong> 为传入的属性每一项都加上readonly修饰符来实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123; <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P] &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="string">&quot;male&quot;</span> | <span class="string">&quot;female&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">Readonly</span>&lt;<span class="title class_">Person</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">p.<span class="property">age</span> = <span class="number">11</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p><strong>Pick&lt;T,K&gt;</strong> 能够帮助我们从传入的属性中摘取某些返回</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从T中选择一组属性K</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Pick</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123; [P <span class="keyword">in</span> K]: T[P] &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Todo</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">description</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">done</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TodoBase</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">Todo</span>, <span class="string">&quot;title&quot;</span> | <span class="string">&quot;done&quot;</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TodoBase</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">done</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Record&lt;K,T&gt;</strong> K对应对象的key，T对应对象的value，返回的就是一个声明好的对象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Record</span>&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = <span class="string">&quot;x&quot;</span> | <span class="string">&quot;y&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PointList</span> = <span class="title class_">Record</span>&lt;<span class="title class_">Point</span>, &#123; <span class="attr">value</span>: <span class="built_in">number</span> &#125;&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">cars</span>: <span class="title class_">PointList</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: &#123; <span class="attr">value</span>: <span class="number">10</span> &#125;,</span><br><span class="line">  <span class="attr">y</span>: &#123; <span class="attr">value</span>: <span class="number">20</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Omit&lt;K,T&gt;</strong> 剔除k中T的属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Omit</span>=<span class="title class_">Pick</span>&lt;T,<span class="title class_">Exclude</span>&lt;keyof T,K&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">email</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserWithoutEmail</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">User</span>, <span class="string">&quot;email&quot;</span>&gt; <span class="comment">// UserWithoutEmail =&#123;id: string;name: string;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br /><br /><br /><br />]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试复习计划之算法</title>
      <link href="/2022/01/01/interview/algorithm/"/>
      <url>/2022/01/01/interview/algorithm/</url>
      
        <content type="html"><![CDATA[<br /><br /><br /><br />]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试复习计划之Vue</title>
      <link href="/2021/10/01/interview/vue/"/>
      <url>/2021/10/01/interview/vue/</url>
      
        <content type="html"><![CDATA[<br /><br /><br /><br />]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试复习计划之网络</title>
      <link href="/2020/10/01/interview/network/"/>
      <url>/2020/10/01/interview/network/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-基本概念"><a href="#HTTP-基本概念" class="headerlink" title="HTTP 基本概念"></a>HTTP 基本概念</h2><p>互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。</p><h2 id="HTTP-工作原理"><a href="#HTTP-工作原理" class="headerlink" title="HTTP 工作原理"></a>HTTP 工作原理</h2><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。客户端向服务器发送一个请求报文，服务器以一个状态行作为响应。</p><h2 id="HTTP请求-x2F-响应步骤"><a href="#HTTP请求-x2F-响应步骤" class="headerlink" title="HTTP请求&#x2F;响应步骤"></a>HTTP请求&#x2F;响应步骤</h2><ul><li>客户端连接到Web服务器</li><li>发送HTTP请求</li><li>服务器接受请求并返回HTTP响应</li><li>释放TCP连接</li><li>客户端解析HTML内容</li></ul><h2 id="GET与POST区别"><a href="#GET与POST区别" class="headerlink" title="GET与POST区别"></a>GET与POST区别</h2><ul><li>安全性：GET参数通过URL传递会暴露、不安全，而POST放在RequestBody中，相对更安全</li><li>针对数据操作的类型不同：GET对数据进行查询，POST主要对数据进行增删改，GET是读，POST是改</li><li>参数大小不同：GET请求在URL中传达的参数是有长度限制，而POST没有限制</li><li>浏览器回退表现不同：GET在浏览器回退时是无害的，而POST会再次提交请求</li><li>浏览器对请求地址的处理不同：GET请求地址会被浏览器主动缓存，而POST不会，除非手动设置</li><li>浏览器对响应的处理不同：GET请求参数会被完整的保留在历览器历史记录里，而POST中的参数不会被保留</li></ul><h2 id="什么是SSL"><a href="#什么是SSL" class="headerlink" title="什么是SSL"></a>什么是SSL</h2><ul><li>SSL是一种安全套接层协议，是Web浏览器与Web服务器之间安全交换信息的协议，提供两个基本的安全服务：鉴别与保密；</li><li>保密：在握手协议中定义了会话密钥后，所有的消息都被加密；</li><li>鉴别：可选的客户端认证，和强制的服务器端认证；</li><li>完整性：传送的消息包括消息完整性检查（使用MAC）；</li><li>SSL介于应用层和TCP层之间，应用层数据不再直接传递给传输层，而是传递给SSL层，SSL层对从应用层收到的数据进行加密，并增加自己的SSL头；</li></ul><h2 id="HTTPS的基本概念"><a href="#HTTPS的基本概念" class="headerlink" title="HTTPS的基本概念"></a>HTTPS的基本概念</h2><ul><li>HTTPS是以安全为目的HTTP通道，即HTTP下加入SSL层进行加密。</li><li>HTTPS协议作用：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</li></ul><h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><ul><li>HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议</li><li>HTTPS 协议需要认证机构（ca）证书，费用较高。</li><li>使用不同的链接方式，端口也不同，一般，HTTP 协议的端口为 80，HTTPS 的端口为 443。</li><li>HTTP 的连接很简单，是无状态的。</li></ul><h2 id="客户端HTTPS与Web服务器通信时的步骤"><a href="#客户端HTTPS与Web服务器通信时的步骤" class="headerlink" title="客户端HTTPS与Web服务器通信时的步骤"></a>客户端HTTPS与Web服务器通信时的步骤</h2><ul><li>客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。</li><li>web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。</li><li>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。</li><li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li><li>web 服务器通过自己的私钥解密出会话密钥。</li><li>web 服务器通过会话密钥加密与客户端之间的通信。</li></ul><h2 id="HTTPS协议的优缺点"><a href="#HTTPS协议的优缺点" class="headerlink" title="HTTPS协议的优缺点"></a>HTTPS协议的优缺点</h2><ul><li>HTTPS 协议要比 http 协议安全，可防止数据在传输过程中被窃取、改变，确保数据的完整性。</li><li>https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li><li>https 缓存不如 http 高效，会增加数据开销。</li><li>SSL 证书也需要钱，功能越强大的证书费用越高。</li><li>SSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。</li></ul><h2 id="什么是TCP-x2F-IP网络模型"><a href="#什么是TCP-x2F-IP网络模型" class="headerlink" title="什么是TCP&#x2F;IP网络模型"></a>什么是TCP&#x2F;IP网络模型</h2><p>TCP&#x2F;IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p><ul><li>链路层：负责封装和解封装IP报文，发送和接受ARP&#x2F;RARP报文等。</li><li>网络层：负责路由以及把分组报文发送给目标网络或主机。</li><li>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</li><li>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</li></ul><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><ul><li>TCP是面向连接的，而UDP是面向无连接的。</li><li>TCP仅支持单播传输，UDP 提供了单播，多播，广播的功能。</li><li>TCP的三次握手保证了连接的可靠性; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</li><li>UDP的头部开销比TCP的更小，数据传输速率更高，实时性更好。</li></ul><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p><ul><li>【你好，我想和你聊一聊？】第一次握手：建立连接时，客户端发送syn包（syn&#x3D;j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号。</li><li>【好的，我有空。】第二次握手：服务器收到syn包并确认客户的SYN（ack&#x3D;j+1），同时也发送一个自己的SYN包（syn&#x3D;k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>【好的，我们开始吧。】第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ul><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><ul><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li><li>服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ul><h2 id="HTTP-请求跨域问题"><a href="#HTTP-请求跨域问题" class="headerlink" title="HTTP 请求跨域问题"></a>HTTP 请求跨域问题</h2><ul><li><p>跨域的原理</p><ul><li>跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的。</li><li>同源策略,是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，都被当作是不同的域。</li><li>跨域原理，即是通过各种方式，避开浏览器的安全限制。</li></ul></li><li><p>解决方案<br>  最初使用的是jsonp，但存在一些问题，使用get请求不安全，携带数据较小，后来也用过iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和proxy代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用proxy，在服务器上使用nginx代理，这样开发过程中彼此都方便，效率也高；现在h5新特性还有 windows.postMessage()。</p><ul><li>JSONP：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">原理：</span><br><span class="line"></span><br><span class="line">ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，</span><br><span class="line">利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</span><br><span class="line"></span><br><span class="line">步骤：</span><br><span class="line"></span><br><span class="line">1 去创建一个script标签</span><br><span class="line">2 script的src属性设置接口地址</span><br><span class="line">3 接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</span><br><span class="line">4 通过定义函数名去接受返回的数据</span><br><span class="line">5 缺点：JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</span><br><span class="line"></span><br><span class="line">//动态创建 script</span><br><span class="line">var script = document.createElement(&#x27;script&#x27;);</span><br><span class="line"></span><br><span class="line">// 设置回调函数</span><br><span class="line">function getData(data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置 script 的 src 属性，并设置请求地址</span><br><span class="line">script.src = &#x27;http://localhost:3000/?callback=getData&#x27;;</span><br><span class="line"></span><br><span class="line">// 让 script 生效</span><br><span class="line">document.body.appendChild(script);</span><br></pre></td></tr></table></figure></li><li>document.domain 基础域名相同 子域名不同。</li><li>window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name。</li><li>CORS 跨域资源共享 是一种机制，是目前主流的跨域解决方案，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求。</li><li>proxy代理 目前常用方式。</li><li>window.postMessage() 利用h5新特性 window.postMessage()。</li><li>Websocket。</li></ul></li></ul><h2 id="Cookie、sessionStorage、localStorage-的区别"><a href="#Cookie、sessionStorage、localStorage-的区别" class="headerlink" title="Cookie、sessionStorage、localStorage 的区别"></a>Cookie、sessionStorage、localStorage 的区别</h2><p><strong>相同点：</strong></p><ul><li>存储在客户端</li></ul><p><strong>不同点：</strong></p><ul><li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li><li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li><li>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</li></ul><h2 id="HTTP状态码及常见状态码"><a href="#HTTP状态码及常见状态码" class="headerlink" title="HTTP状态码及常见状态码"></a>HTTP状态码及常见状态码</h2><p><strong>HTTP状态码</strong></p><ul><li>1xx：指示信息类，表示请求已接受，继续处理</li><li>2xx：指示成功类，表示请求已成功接受</li><li>3xx：指示重定向，表示要完成请求必须进行更近一步的操作</li><li>4xx：指示客户端错误，请求有语法错误或请求无法实现</li><li>5xx：指示服务器错误，服务器未能实现合法的请求</li></ul><p><strong>常见状态码</strong></p><p>2xx（成功）表示成功处理了请求的状态码</p><ul><li>200 - 成功 服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页</li></ul><p>3xx（重定向）表示要完成请求，需要进一步操作；通常，这些状态代码用来重定向</p><ul><li>301 - 永久移动 请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置</li><li>304 - 未修改 自上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容</li></ul><p>4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理</p><ul><li>401 - 未授权 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应</li><li>403 - 禁止 服务器拒绝请求</li><li>404 - 未找到 服务器找不到请求的网页</li></ul><p>5xx（服务器错误）这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错</p><ul><li>500 - 服务器内部错误 服务器遇到错误，无法完成请求</li><li>501 - 尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码</li><li>502 - 错误网关 服务器作为网关或代理，从上游服务器无法收到无效响应</li><li>503 - 服务器不可用 服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态</li><li>504 - 网关超时 服务器作为网关代理，但是没有及时从上游服务器收到请求</li></ul><h2 id="浏览器的缓存机制-强制缓存-amp-amp-协商缓存"><a href="#浏览器的缓存机制-强制缓存-amp-amp-协商缓存" class="headerlink" title="浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存"></a>浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</h2><h2 id="客户端与服务端长连接的几种方式"><a href="#客户端与服务端长连接的几种方式" class="headerlink" title="客户端与服务端长连接的几种方式"></a>客户端与服务端长连接的几种方式</h2><ul><li>ajax 轮询<ul><li>ajax 轮询指客户端每间隔一段时间向服务端发起请求，保持数据的同步。</li><li>优点：可实现基础（指间隔时间较短）的数据更新。</li><li>缺点：这种方法也只是尽量的模拟即时传输，但并非真正意义上的即时通讯，很有可能出现客户端请求时，服务端数据并未更新。或者服务端数据已更新，但客户端未发起请求。导致多次请求资源浪费，效率低下。</li></ul></li><li>long poll 长轮询<ul><li>实现原理： long poll 指的是客户端发送请求之后，如果没有数据返回，服务端会将请求挂起放入队列（不断开连接）处理其他请求，直到有数据返回给客户端。然后客户端再次发起请求，以此轮询。在 HTTP1.0 中客户端可以设置请求头 Connection:keep-alive，服务端收到该请求头之后知道这是一个长连接，在响应报文头中也添加 Connection:keep-alive。客户端收到之后表示长连接建立完成，可以继续发送其他的请求。在 HTTP1.1 中默认使用了 Connection:keep-alive 长连接。</li><li>优点：减少客户端的请求，降低无效的网络传输，保证每次请求都有数据返回，不会一直占用线程。</li><li>缺点：无法处理高并发，当客户端请求量大，请求频繁时对服务器的处理能力要求较高。服务器一直保持连接会消耗资源，需要同时维护多个线程，服务器所能承载的 TCP 连接数是有上限的，这种轮询很容易把连接数顶满。每次通讯都需要客户端发起，服务端不能主动推送。</li></ul></li><li>iframe 长连接<ul><li>实现原理：在网页上嵌入一个 iframe 标签，该标签的 src 属性指向一个长连接请求。这样服务端就可以源源不断地给客户端传输信息。保障信息实时更新。</li><li>优点：消息及时传输。</li><li>缺点：消耗服务器资源。</li></ul></li><li>WebSocket<ul><li>实现原理： Websocket 实现了客户端与服务端的双向通信，只需要连接一次，就可以相互传输数据，很适合实时通讯、数据实时更新等场景。</li><li>Websocket 协议与 HTTP 协议没有关系，它是一个建立在 TCP 协议上的全新协议，为了兼容 HTTP 握手规范，在握手阶段依然使用 HTTP 协议，握手完成之后，数据通过 TCP 通道进行传输。</li><li>Websoket 数据传输是通过 frame 形式，一个消息可以分成几个片段传输。这样大数据可以分成一些小片段进行传输，不用考虑由于数据量大导致标志位不够的情况。也可以边生成数据边传递消息，提高传输效率。</li><li>优点： 双向通信。客户端和服务端双方都可以主动发起通讯。 没有同源限制。客户端可以与任意服务端通信，不存在跨域问题。 数据量轻。第一次连接时需要携带请求头，后面数据通信都不需要带请求头，减少了请求头的负荷。 传输效率高。因为只需要一次连接，所以数据传输效率高。</li><li>缺点：需要后端代码稳定，受网络限制大，兼容性差，维护成本高，生态圈小。</li></ul></li></ul><h2 id="非对称加密RSA"><a href="#非对称加密RSA" class="headerlink" title="非对称加密RSA"></a>非对称加密RSA</h2><ul><li>非对称加密算法需要两个密钥：公开密钥(publickey) 和私有密(privatekey) 。</li><li>与对称加密算法的对比：对称加密只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。非对称加密有两种密钥，其中一个是公开的。</li><li>RSA应用场景：由于RSA算法的加密解密速度要比对称算法速度慢很多，在实际应用中，通常采取数据本身的加密和解密使用对称加密算法(AES)。 用RSA算法加密并传输对称算法所需的密钥。</li></ul><h2 id="HTTP1、HTTP2、HTTP3"><a href="#HTTP1、HTTP2、HTTP3" class="headerlink" title="HTTP1、HTTP2、HTTP3"></a>HTTP1、HTTP2、HTTP3</h2><p>HTTP&#x2F;2 相比于 HTTP&#x2F;1.1，可以说是大幅度提高了网页的性能，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，虽如此但HTTP&#x2F;2并非完美的，HTTP&#x2F;3 就是为了解决 HTTP&#x2F;2 所存在的一些问题而被推出来的。</p><br /><br /><br /><br />]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试复习计划之浏览器</title>
      <link href="/2020/05/01/interview/browser/"/>
      <url>/2020/05/01/interview/browser/</url>
      
        <content type="html"><![CDATA[<h2 id="从输入URL到页面加载的全过程"><a href="#从输入URL到页面加载的全过程" class="headerlink" title="从输入URL到页面加载的全过程"></a>从输入URL到页面加载的全过程</h2><ul><li>1、首先在浏览器输入URL</li><li>2、查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。<ul><li>浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；</li><li>操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；</li><li>路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；</li><li>ISP缓存：若上述均失败，继续向ISP搜索。</li></ul></li><li>3、DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</li><li>4、建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接</li><li>5、发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器</li><li>6、服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器</li><li>7、关闭TCP连接：通过四次挥手释放TCP连接</li><li>8、浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：<ul><li>构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象</li><li>构建CSS规则树：生成CSS规则树（CSS Rule Tree）</li><li>构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）</li><li>布局（Layout）：计算出每个节点在屏幕中的位置</li><li>绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。</li></ul></li><li>9、JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）<ul><li>创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。</li><li>加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译</li><li>预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为’undefined’；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。</li><li>解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。</li></ul></li></ul><h2 id="在浏览器中输入URL到显示页面经历哪些过程，涉及到哪些协议？"><a href="#在浏览器中输入URL到显示页面经历哪些过程，涉及到哪些协议？" class="headerlink" title="在浏览器中输入URL到显示页面经历哪些过程，涉及到哪些协议？"></a>在浏览器中输入URL到显示页面经历哪些过程，涉及到哪些协议？</h2><p>浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</p><p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。</p><p><code>1、DNS协议，http协议，https协议属于应用层</code></p><p>应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。</p><p><code>2、TCP/UDP属于传输层</code></p><p>传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议TCP，和无连接的用户数据报协议UDP。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。</p><p><code>3、IP协议，ARP协议属于网络层</code></p><p>网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP&#x2F;IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。</p><p><code>4、数据链路层</code></p><p>当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及流量控制信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。</p><p><code>5、物理层</code></p><p>物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。</p><h2 id="浏览器的工作原理"><a href="#浏览器的工作原理" class="headerlink" title="浏览器的工作原理"></a>浏览器的工作原理</h2><ul><li>渲染引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：渲染树。</li><li>渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</li><li>渲染树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 渲染引擎会遍历渲染树，由用户界面后端层将每个节点绘制出来。</li><li>这是一个渐进的过程。为达到更好的用户体验，渲染引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。</li></ul><h2 id="浏览器是如何渲染UI的？"><a href="#浏览器是如何渲染UI的？" class="headerlink" title="浏览器是如何渲染UI的？"></a>浏览器是如何渲染UI的？</h2><ul><li>浏览器获取HTML文件，然后对文件进行解析，形成DOM Tree;</li><li>与此同时，进行CSS解析，生成Style Rules;</li><li>接着将DOM Tree与Style Rules合成为 Render Tree;</li><li>接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标;</li><li>随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来;</li></ul><h2 id="DOM-Tree是如何构建的？"><a href="#DOM-Tree是如何构建的？" class="headerlink" title="DOM Tree是如何构建的？"></a>DOM Tree是如何构建的？</h2><ul><li>转码: 浏览器将接收到的二进制数据按照指定编码格式转化为HTML字符串</li><li>生成Tokens: 之后开始parser，浏览器会将HTML字符串解析成Tokens</li><li>构建Nodes: 对Node添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope</li><li>生成DOM Tree: 通过node包含的指针确定的关系构建出DOM Tree</li></ul><h2 id="浏览器重绘与重排的区别？"><a href="#浏览器重绘与重排的区别？" class="headerlink" title="浏览器重绘与重排的区别？"></a>浏览器重绘与重排的区别？</h2><ul><li>重排&#x2F;回流（Reflow）：当DOM的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素;</li><li>重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变;</li><li>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分;</li><li>重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘;</li><li>重绘不一定会出现重排，重排必然会出现重绘;</li></ul><h2 id="如何触发重排和重绘？"><a href="#如何触发重排和重绘？" class="headerlink" title="如何触发重排和重绘？"></a>如何触发重排和重绘？</h2><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p><ul><li>添加、删除、更新DOM节点;</li><li>通过display: none隐藏一个DOM节点-触发重排和重绘;</li><li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化;</li><li>移动或者给页面中的DOM节点添加动画;</li><li>添加一个样式表，调整样式属性;</li><li>用户行为，例如调整窗口大小，改变字号，或者滚动;</li></ul><h2 id="如何避免重绘或者重排？"><a href="#如何避免重绘或者重排？" class="headerlink" title="如何避免重绘或者重排？"></a>如何避免重绘或者重排？</h2><ul><li>集中改变样式，不要一条一条地修改 DOM 的样式。</li><li>不要把 DOM 结点的属性值放在循环里当成循环里的变量。</li><li>为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。</li><li>不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</li><li>尽量只修改position：absolute或fixed元素，对其他元素影响不大</li><li>动画开始GPU加速，translate使用3D变化</li><li>提升为合成层,将元素提升为合成层有以下优点：<ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快;</li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层;</li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint;  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 提升合成层的最好方式是使用 CSS 的 <span class="attribute">will-change</span> 属性： --&gt;</span><br><span class="line"><span class="selector-id">#target</span> &#123;</span><br><span class="line">    <span class="attribute">will-change</span>: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="JS垃圾回收机制"><a href="#JS垃圾回收机制" class="headerlink" title="JS垃圾回收机制"></a>JS垃圾回收机制</h2><ul><li>项目中，如果存在大量不被释放的内存（堆&#x2F;栈&#x2F;上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存;</li><li>浏览器垃圾回收机制&#x2F;内存回收机制: 浏览器的Javascript具有自动垃圾回收机制(GC:Garbage Collecation)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存;<ul><li>标记清除:在js中，最常用的垃圾回收机制是标记清除：当变量进入执行环境时，被标记为“进入环境”，当变量离开执行环境时，会被标记为“离开环境”。垃圾回收器会销毁那些带标记的值并回收它们所占用的内存空间;</li><li>谷歌浏览器：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收;</li><li>IE浏览器：“引用计数法”，当前内存被占用一次，计数累加1次，移除占用就减1，减到0时，浏览器就回收它;</li></ul></li><li>优化手段：内存优化 ; 手动释放：取消内存的占用即可;<ul><li>堆内存：fn &#x3D; null 【null：空指针对象】;</li><li>栈内存：把上下文中，被外部占用的堆的占用取消即可;</li></ul></li><li>内存泄漏<ul><li>在 JS 中，常见的内存泄露主要有 4 种,全局变量、闭包、DOM 元素的引用、定时器;</li></ul></li></ul><br /><br /><br /><br />]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试复习计划之JavaScript</title>
      <link href="/2020/01/01/interview/javascript/"/>
      <url>/2020/01/01/interview/javascript/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><ul><li>面向对象简而言之就是程序中所有的操作都是通过对象来完成。主要是对对象单词的理解，在计算机当中一种事物到了程序中就变成对象，一条狗就是一个事物。程序中所有的对象被分为两部分属性、方法，以一条狗为例，属性一只动物、性别公、毛色黑这是它的数据，它会叫这是它的功能，同样在程序中，数据是属性、功能是方法。</li><li>如何创建对象就要先定义类，可以理解为对象模型，Dog类创建狗的模型，不同的类用来创建不同的对象。</li></ul><h2 id="类、构造函数"><a href="#类、构造函数" class="headerlink" title="类、构造函数"></a>类、构造函数</h2><ul><li>类 class</li></ul>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  name;</span><br><span class="line">  age;</span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>()</span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="keyword">new</span> <span class="title class_">Dog</span>()</span><br></pre></td></tr></table></figure><ul><li>构造函数 constructor</li></ul>  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// this -&gt; dog dog1</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Mike&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Joi&#x27;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="new操作符的实例化过程"><a href="#new操作符的实例化过程" class="headerlink" title="new操作符的实例化过程"></a>new操作符的实例化过程</h2><ul><li>创建空对象</li><li>空对象隐式原型__proto__指向构造函数的原型</li><li>将空对象作为构造函数的上下文</li><li>判断构造函数返回值是否为对象，如果为对象就使用构造函数返回的值，否则使用 obj</li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * new Create() 的过程，可以通过该函数来模拟</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params</span> &#123;<span class="type">Function</span>&#125; fn new操作符的目标函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params</span> &#123;<span class="type">Array</span>&#125; args 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// obj.__proto__ = fn.prototype</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, fn.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变构造函数指向 并 执行</span></span><br><span class="line">    <span class="keyword">let</span> result = fn.<span class="title function_">apply</span>(obj, args)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果构造函数返回值为对象则返回对象，否则返回 obj</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;BMW&#x27;</span>).<span class="property">name</span> <span class="comment">// &#x27;BMW&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;mercedes-benz&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;BMW&#x27;</span>).<span class="property">name</span> <span class="comment">// &#x27;mercedes-benz&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="作用域及作用域链"><a href="#作用域及作用域链" class="headerlink" title="作用域及作用域链"></a>作用域及作用域链</h2><p><strong>作用域</strong></p><ul><li>当前创建函数或变量所处的上下文</li><li>ES6之前有全局作用域、函数作用域，现在又有了块级作用域</li><li>内部作用域可访问外部作用域，外部作用域访问不了内部作用域，起到隔离保护作用</li></ul><p><strong>作用域链</strong></p><ul><li>变量取值，如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，查找过程形成的链条就叫做作用域链</li></ul><h2 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h2><p><strong>原型关系：</strong></p><ul><li>每个 class都有显示原型 prototype</li><li>每个实例都有隐式原型 <strong>proto</strong></li><li>实例的 <strong>proto</strong> 指向对应 class 的 prototype</li></ul><p><strong>原型：</strong></p><p>在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象。</p><p><strong>原型链：</strong></p><p>函数的原型链对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针__proto__,该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用__proto__一直指向Object的原型对象上，而Object原型对象用Object.prototype.__ proto__ &#x3D; null表示原型链顶端。如此形成了js的原型链继承。同时所有的js对象都有Object的基本防范</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>  - </p><h2 id="JS中的数据类型及区别"><a href="#JS中的数据类型及区别" class="headerlink" title="JS中的数据类型及区别"></a>JS中的数据类型及区别</h2><p><strong>基本类型(值类型)：</strong></p><ul><li>Number(数字)、String(字符串)、Boolean(布尔)、null(空)、undefined(未定义)、Symbol(符号)、BigInt(精度整数)</li></ul><p><strong>引用类型(复杂数据类型)：</strong></p><ul><li>Object(对象)、Function(函数)、Array(数组)、Date(日期)、RegExp(正则表达式)、Global、Math(单体内置对象)</li></ul><h2 id="JS中的数据类型检测方案"><a href="#JS中的数据类型检测方案" class="headerlink" title="JS中的数据类型检测方案"></a>JS中的数据类型检测方案</h2><p><strong>typeof</strong></p><ul><li>优点：可以区分基本类型</li><li>缺点：不能详细区分引用类型，<code>Null</code> 被认为 <code>Object</code> 类型</li></ul><p><strong>instanceof</strong></p><ul><li>用于判断一个引用类型是否属于某构造函数</li><li>还可以在继承关系中用来判断一个实例是否属于它的父类型</li><li>优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象</li><li>缺点：Number，Boolean，String基本数据类型不能判断</li></ul><p><strong>Object.prototype.toString.call()</strong></p><ul><li>优点：精准判断任何数据类型</li></ul><h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><p>在块作用域内，let声明的变量只是<strong>创建时被提升</strong>，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// Cannot access &#x27;a&#x27; before initialization</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><h4 id="JS-中-this-的情况"><a href="#JS-中-this-的情况" class="headerlink" title="JS 中 this 的情况"></a>JS 中 this 的情况</h4><ul><li>普通函数调用：通过函数名()直接调用：this指向全局对象window（注意let定义的变量不是window属性，只有window.xxx定义的才是。即let a &#x3D;’aaa’; this.a是undefined）</li><li>构造函数调用：函数作为构造函数，用new关键字调用时：this指向新new出的对象</li><li>对象函数调用：通过对象.函数名()调用的：this指向这个对象</li><li>箭头函数调用：箭头函数里面没有 this ，所以永远是上层作用域this（上下文）</li><li>apply和call调用：函数体内 this 的指向的是 call&#x2F;apply 方法第一个参数，若为空默认是指向全局对象window。</li><li>函数作为数组的一个元素，通过数组下标调用的：this指向这个数组</li><li>函数作为window内置函数的回调函数调用：this指向window（如setInterval setTimeout 等）</li></ul><h4 id="call-x2F-apply-x2F-bind-的区别"><a href="#call-x2F-apply-x2F-bind-的区别" class="headerlink" title="call&#x2F;apply&#x2F;bind 的区别"></a>call&#x2F;apply&#x2F;bind 的区别</h4><ul><li>fn.call(obj, 1, 2) 函数立即调用</li><li>fn.apply(obj, [1, 2]) 函数立即调用</li><li>fn.bind(obj, 1, 2) 返回对应函数</li></ul><h4 id="箭头函数的特性"><a href="#箭头函数的特性" class="headerlink" title="箭头函数的特性"></a>箭头函数的特性</h4><ul><li>没有自己的this，会捕获其所在的上下文的this值，作为自己的this值</li><li>没有constructor，是匿名函数，不能作为构造函数，不能通过new 调用</li><li>没有原型属性 Fn.prototype 值为 undefined</li><li>不能当做Generator函数,不能使用yield关键字</li></ul><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><ul><li>微任务：Promise回调 mutation回调</li><li>宏任务：DOM事件回调 Ajax回调 定时器回调</li></ul><p><strong>同步及异步执行循序</strong></p><ul><li>代码自上而下执行</li><li>遇到同步代码，执行同步代码</li><li>遇到异步代码，将它的回调函数存到事件队列中</li><li>同步代码执行完，从事件队列中将异步回调函数按顺序执行</li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>) <span class="comment">// 同步</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>), <span class="number">0</span>) <span class="comment">// 异步</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>) <span class="comment">// 同步</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： 1 3 2</span></span><br></pre></td></tr></table></figure><p><strong>异步在事件队列中的执行顺序</strong></p><ul><li>事件队列中先执行 微任务 再执行 宏任务</li><li>执行宏任务时，遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前宏任务的微任务队列</li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>) <span class="comment">// 同步</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>) <span class="comment">// 异步：宏任务 setTimeout1</span></span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步：微任务 then1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>) <span class="comment">// 同步</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>) <span class="comment">// 同步</span></span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步：微任务 then2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>) <span class="comment">// 异步：宏任务 setTimeout2</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">8</span>) <span class="comment">// 同步</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1，4，5，8 6 2 3 7</span></span><br></pre></td></tr></table></figure><h2 id="模块化的理解"><a href="#模块化的理解" class="headerlink" title="模块化的理解"></a>模块化的理解</h2><p><strong>namespace</strong></p><ul><li>优点：通过对象的形式对变量进行包裹，避免命名冲突</li><li>缺点：定义的命名空间可以被外部任意修改</li></ul><p><strong>IIFE立即执行函数式</strong></p><ul><li>函数内的变量不会造成全局污染</li><li>函数执行完后就会立即销毁，不会造成资源浪费</li><li>缺点：很难对模块进行拆分并完成相互通讯，不可复用</li></ul><p><strong>AMD 异步模块定义</strong></p><ul><li>它采用异步的方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在回调函数中，等到加载完成之后，这个回调函数才会运行。</li><li>引入模块需要用到 RequireJS</li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 引入require.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 moduleA.js 导出</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&quot;module A&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 引入</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;moduleA&quot;</span>], <span class="keyword">function</span>(<span class="params">moduleA</span>)&#123;</span><br><span class="line">  moduleA.<span class="title function_">getName</span>()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>CMD 按需加载</strong></p><ul><li>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出</li><li>依赖就近，用的时候再require</li><li>相对于 AMD，对依赖模块的执行时机处理不同</li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> clock = <span class="built_in">require</span>(<span class="string">&#x27;clock&#x27;</span>);</span><br><span class="line">  clock.<span class="title function_">start</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>CJS</strong></p><ul><li>CommonJs是Nodejs内置的同步加载的模块化机制</li><li>导出值为简单类型是复制，导出值为复杂类型是浅拷贝输出，模块会被缓存，可修改导出的值</li><li>可写在函数体中使用require引入</li><li>this是当前模块</li><li>运行时进行加载模块</li></ul><p><strong>UMD</strong></p><ul><li>通用模块定义，兼容了CmmonJS和AMD规范</li><li>判断全局是否存在exports和define，如果存在exports，那么以CommonJS的方式暴露模块，如果存在define那么以AMD的方式暴露模块</li></ul><p><strong>ESM</strong></p><ul><li>存在提升行为，会提升到整个模块的头部，首先执行</li><li>不允许修改引入的值，属于只读引用</li><li>编译时输出</li><li>对于动态 import().then 来说，原始值发生变化，import加载的值也会发生变化</li><li>this是undefined</li><li>浏览器加载 ESM，使用 <code>&lt;script&gt;</code> 标签，要加入 type&#x3D;”module” 属性</li><li>具有更好的可摇树性</li></ul><h2 id="JavaScript的设计模式"><a href="#JavaScript的设计模式" class="headerlink" title="JavaScript的设计模式"></a>JavaScript的设计模式</h2><p><strong>解决某个特定场景下对某种问题的解决方案</strong></p><table><thead><tr><th>设计模式</th><th>特点</th><th>案例</th></tr></thead><tbody><tr><td>单例模式</td><td>只有一个实例可以全局访问</td><td>弹框组件（先创建再隐藏，需要时显示创建；对应模式只有一个实例）</td></tr><tr><td>策略模式</td><td>根据不同参数可以命中不同的策略</td><td>if else 根据不同参数做出处理</td></tr><tr><td>代理模式</td><td>代理对象和本体对象具有一致的接口</td><td>虚拟代理（图片预加载）；缓存代理（累积计算）</td></tr><tr><td>中介者模式</td><td>对象和对象之间借助第三方中介者进行通信</td><td>测试结束告知结果</td></tr><tr><td>装饰者模式</td><td>动态地给函数赋能</td><td>天冷了穿衣服，热了脱衣服</td></tr><tr><td>发布-订阅模式</td><td>事件发布&#x2F;订阅模式</td><td>微信小程序的 emit&#x2F;on 监听事件</td></tr><tr><td>观察者模式</td><td>当观察对象发生变化时自动调用相关函数</td><td>vue 双向绑定 Proxy</td></tr></tbody></table><br /><br /><br /><br />]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试复习计划之Css</title>
      <link href="/2019/01/01/interview/css/"/>
      <url>/2019/01/01/interview/css/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML5-语义化标签"><a href="#HTML5-语义化标签" class="headerlink" title="HTML5 语义化标签"></a>HTML5 语义化标签</h2><ul><li><code>header</code> <code>nav</code> <code>main</code> <code>article</code> <code>section</code> <code>aside</code> <code>footer</code></li><li>代码结构清晰，易于阅读</li><li>利于开发和维护 方便其他设备解析（如屏幕阅读器）根据语义渲染网页</li><li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</li></ul><h2 id="HTML5-新特性"><a href="#HTML5-新特性" class="headerlink" title="HTML5 新特性"></a>HTML5 新特性</h2><ul><li>语义化标签</li><li>音视频处理API(audio,video)</li><li>canvas &#x2F; webGL</li><li>拖拽释放(Drag and drop) API</li><li>history API</li><li>requestAnimationFrame</li><li>地理位置(Geolocation)API</li><li>webSocket</li><li>web存储 localStorage、SessionStorage</li><li>表单控件，calendar、date、time、email、url、search</li></ul><h2 id="CSS-选择器及优先级"><a href="#CSS-选择器及优先级" class="headerlink" title="CSS 选择器及优先级"></a>CSS 选择器及优先级</h2><p><strong>选择器</strong></p><ul><li>id选择器(#myid)</li><li>类选择器(.myclass)</li><li>属性选择器(a[rel&#x3D;”external”])</li><li>伪类选择器(a:hover, li:nth-child)</li><li>标签选择器(div, h1,p)</li><li>相邻选择器（h1 + p）</li><li>子选择器(ul &gt; li)</li><li>后代选择器(li a)</li><li>通配符选择器(*)</li></ul><p><strong>优先级</strong> <code>!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</code></p><ul><li>!important</li><li>内联样式（1000）</li><li>ID选择器（0100）</li><li>类选择器&#x2F;属性选择器&#x2F;伪类选择器（0010）</li><li>元素选择器&#x2F;伪元素选择器（0001）</li><li>关系选择器&#x2F;通配符选择器（0000）</li></ul><h2 id="渐进增强与优雅降级的理解及区别"><a href="#渐进增强与优雅降级的理解及区别" class="headerlink" title="渐进增强与优雅降级的理解及区别"></a>渐进增强与优雅降级的理解及区别</h2><p><strong>渐进增强（Progressive Enhancement）：</strong> 一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</p><p><strong>优雅降级（Graceful Degradation）：</strong> 一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。 两者区别 1、广义： 其实要定义一个基准线，在此之上的增强叫做渐进增强，在此之下的兼容叫优雅降级 2、狭义： 渐进增强一般说的是使用CSS3技术，在不影响老浏览器的正常显示与使用情形下来增强体验，而优雅降级则是体现html标签的语义，以便在js&#x2F;css的加载失败&#x2F;被禁用时，也不影响用户的相应功能。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 例子 */</span></span><br><span class="line"><span class="selector-class">.transition</span> &#123; <span class="comment">/*渐进增强写法*/</span></span><br><span class="line">  -webkit-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">     -moz-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">       -o-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">          <span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.transition</span> &#123; <span class="comment">/*优雅降级写法*/</span></span><br><span class="line">          <span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">       -o-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">     -moz-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">  -webkit-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h2><p>过渡<code>transition</code>、动画<code>animation</code>、形状转换<code>transform</code>、选择器<code>nth-of-type()</code>、阴影、边框、背景、文字、渐变、Filter（滤镜）、弹性布局、栅格布局、多列布局、媒体查询</p><h2 id="position-属性的值有哪些及其区别"><a href="#position-属性的值有哪些及其区别" class="headerlink" title="position 属性的值有哪些及其区别"></a>position 属性的值有哪些及其区别</h2><ul><li>固定定位 fixed： 元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定 位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重叠。</li><li>相对定位 relative： 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直 或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是 否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</li><li>绝对定位 absolute： 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那 么它的位置相对于。absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。</li><li>粘性定位 sticky： 元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定 位，之后为固定定位。</li><li>默认定位 Static： 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声 明）。 inherit: 规定应该从父元素继承 position 属性的值。</li></ul><h2 id="box-sizing属性"><a href="#box-sizing属性" class="headerlink" title="box-sizing属性"></a>box-sizing属性</h2><ul><li>box-sizing 规定两个并排的带边框的框，语法为 box-sizing：content-box&#x2F;border-box&#x2F;inherit</li><li>content-box：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框。【标准盒子模型】</li><li>border-box：为元素设定的宽度和高度决定了元素的边框盒。【IE 盒子模型】</li><li>inherit：继承父元素的 box-sizing 值</li></ul><h2 id="CSS-盒子模型"><a href="#CSS-盒子模型" class="headerlink" title="CSS 盒子模型"></a>CSS 盒子模型</h2><p>CSS 盒模型本质上是一个盒子，它包括：边距，边框，填充和实际内容。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。</p><ul><li>在标准的盒子模型中，width 指 content 部分的宽度。</li><li>在 IE 盒子模型中，width 表示 content+padding+border 这三个部分的宽度。</li><li>标准盒模型： 一个块的总宽度 &#x3D; width+margin(左右)+padding(左右)+border(左右)</li><li>怪异盒模型： 一个块的总宽度 &#x3D; width+margin（左右）（既 width 已经包含了 padding 和 border 值）</li></ul><h2 id="BFC（块级格式上下文）"><a href="#BFC（块级格式上下文）" class="headerlink" title="BFC（块级格式上下文）"></a>BFC（块级格式上下文）</h2><p>BFC 是 Block Formatting Context 的缩写，即块级格式化上下文。BFC是CSS布局的一个概念，是一个独立的渲染区域，规定了内部box如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC 的高度的时候，浮动元素也参与计算。</p><p><strong>BFC的原理布局规则</strong></p><ul><li>内部的Box会在垂直方向，一个接一个地放置</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反</li><li>BFC的区域不会与float box重叠</li><li>BFC是一个独立容器，容器里面的子元素不会影响到外面的元素</li><li>计算BFC的高度时，浮动元素也参与计算高度</li><li>元素的类型和display属性，决定了这个Box的类型。不同类型的Box会参与不同的Formatting Context</li></ul><p><strong>如何创建BFC</strong></p><ul><li>根元素，即HTML元素</li><li>float的值不为none</li><li>position为absolute或fixed</li><li>display的值为inline-block、table-cell、table-caption</li><li>overflow的值不为visible</li></ul><p><strong>BFC的使用场景</strong></p><ul><li>去除边距重叠现象</li><li>清除浮动（让父元素的高度包含子浮动元素）</li><li>避免某元素被浮动元素覆盖</li><li>避免多列布局由于宽度计算四舍五入而自动换行</li></ul><h2 id="让一个元素水平垂直居中"><a href="#让一个元素水平垂直居中" class="headerlink" title="让一个元素水平垂直居中"></a>让一个元素水平垂直居中</h2><p><strong>水平居中</strong></p><ul><li><p>对于 行内元素 : text-align: center;</p></li><li><p>对于确定宽度的块级元素：</p><ul><li>width和margin实现。margin: 0 auto;</li><li>绝对定位和margin-left: margin-left: (父width - 子width）&#x2F;2, 前提是父元素position: relative</li></ul></li><li><p>对于宽度未知的块级元素</p><ul><li>table标签配合margin左右auto实现水平居中。使用table标签（或直接将块级元素设值为 display:table），再通过给该标签添加左右margin为auto。</li><li>inline-block实现水平居中方法。display：inline-block和text-align:center实现水平居中。</li><li>绝对定位+transform，translateX可以移动本身元素的50%。</li><li>flex布局使用justify-content:center</li></ul></li></ul><p><strong>垂直居中</strong></p><ul><li>利用 line-height 实现居中，这种方法适合纯文字类</li><li>通过设置父容器 相对定位 ，子级设置 绝对定位，标签通过margin实现自适应居中</li><li>弹性布局 flex :父级设置display: flex; 子级设置margin为auto实现自适应居中</li><li>父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现</li><li>table 布局，父级通过转换成表格形式，然后子级设置 vertical-align 实现。（需要注意的是：vertical-align: middle使用的前提条件是内联元素以及display值为table-cell的元素）。</li></ul><h2 id="用CSS实现三角符号"><a href="#用CSS实现三角符号" class="headerlink" title="用CSS实现三角符号"></a>用CSS实现三角符号</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记忆口诀：盒子宽高均为零，三面边框皆透明。 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">100px</span> solid <span class="number">#ff0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><ul><li>Flex 布局</li><li>Rem 布局</li><li>百分比布局</li><li>浮动布局</li></ul><h2 id="如何使用rem或viewport进行移动端适配"><a href="#如何使用rem或viewport进行移动端适配" class="headerlink" title="如何使用rem或viewport进行移动端适配"></a>如何使用rem或viewport进行移动端适配</h2><p><strong>rem适配原理：</strong>改变了一个元素在不同设备上占据的css像素的个数。</p><ul><li>优点：没有破坏完美视口</li><li>缺点：px值转换rem太过于复杂(下面我们使用less来解决这个问题)</li></ul><p><strong>viewport适配的原理：</strong>每一个元素在不同设备上占据的css像素的个数是一样的。但是css像素和物理像素的比例是不一样的，等比的。</p><ul><li>在我们设计图上所量取的大小即为我们可以设置的像素大小，即所量即所设</li><li>缺点破坏完美视口</li></ul><h2 id="清除浮动的方式"><a href="#清除浮动的方式" class="headerlink" title="清除浮动的方式"></a>清除浮动的方式</h2><ul><li>父级添加overflow属性，或者设置高度</li><li>添加额外标签<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    //添加额外标签并且添加clear属性</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear:both&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    //也可以加一个br标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>建立伪类选择器清除浮动<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//在css中添加<span class="selector-pseudo">:after</span>伪元素</span><br><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="comment">/* 设置添加子元素的内容是空 */</span></span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">/* 设置添加子元素为块级元素 */</span></span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="comment">/* 设置添加的子元素的高度0 */</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 设置添加子元素看不见 */</span></span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">    <span class="comment">/* 设置clear：both */</span></span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><br /><br /><br /><br />]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
