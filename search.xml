<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从不考勤制度探讨自律</title>
      <link href="/2023/03/29/story/%E6%95%85%E4%BA%8B%E4%BC%9A-%E4%B8%8D%E8%80%83%E5%8B%A4%E6%8E%A2%E8%AE%A8%E8%87%AA%E5%BE%8B/"/>
      <url>/2023/03/29/story/%E6%95%85%E4%BA%8B%E4%BC%9A-%E4%B8%8D%E8%80%83%E5%8B%A4%E6%8E%A2%E8%AE%A8%E8%87%AA%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wx.zsxq.com/dweb2/index/topic_detail/814251121181482">https://wx.zsxq.com/dweb2/index/topic_detail/814251121181482</a></p>]]></content>
      
      
      <categories>
          
          <category> 故事会 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故事会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试复习计划之项目实战</title>
      <link href="/2023/03/06/interview/project/"/>
      <url>/2023/03/06/interview/project/</url>
      
        <content type="html"><![CDATA[<h2 id="10种鉴权方法"><a href="#10种鉴权方法" class="headerlink" title="10种鉴权方法"></a>10种鉴权方法</h2><h3 id="HTTP-基本鉴权"><a href="#HTTP-基本鉴权" class="headerlink" title="HTTP 基本鉴权"></a>HTTP 基本鉴权</h3><pre><code>- 账号密码通过加密的方式调取服务认证- 缺点：请求过于暴露会被重放攻击</code></pre><h3 id="Seesion-Cookie鉴权"><a href="#Seesion-Cookie鉴权" class="headerlink" title="Seesion-Cookie鉴权"></a>Seesion-Cookie鉴权</h3><pre><code>- 利用服务端的 Session（会话）和 浏览器的 Cookie 来实现的前后端通信认证模式- 客户端发送请求到服务器，服务器生成 SessionId 存储在 Session 服务器中，并返回客户端并设置 Cookie 存储 SessionId- 客户端拿 SessionId 发送请求，服务器校验 Session- 缺点：过于依赖 Cookie、移动端对 Cookie 支持不友好、用户量大服务器开销大</code></pre><h3 id="Token鉴权"><a href="#Token鉴权" class="headerlink" title="Token鉴权"></a>Token鉴权</h3><pre><code>- Token 组成：uid (用户唯一的身份标识) + time (当前时间的时间戳) + sign (签名，Token 的前几位以哈希算法压缩成的一定长度的十六进制字符串)- 客户端发送请求，请求通过服务端生成一个加密后的 Token 令牌- 客户端存储 Token 至缓存中，下次发送请求将 Token 放至请求头 Authorization 字段- 服务端拿到请求令牌后，进行解密和签名校验，如果验证不成功返回 401- 为了避免 Token 时效期短，采用 AccessToken 和 RefreshToken，先用 AccessToken 请求，如果过期再用 RefreshToken 请求- RefreshToken 过期就重新登录，如果没有过期，服务器返回新的 AccessToken，用于下次请求</code></pre><h3 id="JWT（JSON-WEB-TOKEN）鉴权"><a href="#JWT（JSON-WEB-TOKEN）鉴权" class="headerlink" title="JWT（JSON WEB TOKEN）鉴权"></a>JWT（JSON WEB TOKEN）鉴权</h3><pre><code>- JWT 组成： Header 头部、 Payload 负载 和 Signature 签名- 客户端发送请求至服务器，服务器校验通过后使用密钥创建 JWT，发送给客户端- 客户端存储到本地，请求时设置请求头 Authorization 为 JWT- 服务端拿到 JWT，检验是否过期，解析用户信息，处理相关数据- 想比于 Token，降低服务端查询数据库的次数，减少查询用户信息的次数</code></pre><h3 id="单点登录-SSO"><a href="#单点登录-SSO" class="headerlink" title="单点登录 SSO"></a>单点登录 SSO</h3><pre><code>- 1同域名下的 SSO，采用 Seesion-Cookie 的方式，附加在响应头的 Set-Cookie 字段中，设置 Cookie 的 Domain 为 .主域.com- 客户端发送请求，携带主域名 Domain 下的 Cookie 给服务器，通过 Cookie 来验证登录状态- 2不同域名下的 SSO，通过中间方式进行颁布令牌- 通过 CAS 认证服务中心，生成 TGC 放入自己的 Session 中，同时以 Set-Cookie 形式写入 Domain 为 sso.com 的域下 ；同时生成一个授权令牌 ST（类似Token）- 客户端再发送请求需要拿着 ST 向 CAS 认证服务发送请求，CAS 认证服务验证票据 (ST) 的有效性</code></pre><h3 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><pre><code>- 允许用户授权第三方网站 - 授权码模式（微信登录）：客户端跳转第三方网站授权登录换取授权码 - 客户端使用授权码调用服务端获取token - 客户端使用token访问资源- 授权码隐藏式：跳过授权码直接返回token - 前端将本地存储的 client_secret 与 token 进行校验- 用户名密码式模式：用户在客户端提交账号密码换token - 客户端使用token访问资源- 客户端模式：客户端使用自己的标识换token - 客户端使用token访问资源</code></pre><h3 id="联合登录和信任登录"><a href="#联合登录和信任登录" class="headerlink" title="联合登录和信任登录"></a>联合登录和信任登录</h3><pre><code>- 联合登录：APP内嵌H5，登录态Token附加在URL参数上或者采用通信协议</code></pre><h3 id="唯一登录"><a href="#唯一登录" class="headerlink" title="唯一登录"></a>唯一登录</h3><pre><code>- 客户端A与服务端产生对应的 Token，同时也保存登录状态- 客户端B在次登录，检测有登录状态，重新生成Token</code></pre><h3 id="扫码登录"><a href="#扫码登录" class="headerlink" title="扫码登录"></a>扫码登录</h3><pre><code>- PC端请求二维码 - 生成二维码UUID、关联UUID和设备信息、设置过期时间 - 前端展示二维码、定时轮询刷新- 手机扫码获取UUID - 将设备信息和UUID发送给服务端 - 服务端将ID和用户信息绑定生成临时token - 二维码更新为待确认- 手机携带临时token登录 - 服务端将临时token转成真实token - 二维码状态更新为已确认</code></pre><h3 id="一键登录"><a href="#一键登录" class="headerlink" title="一键登录"></a>一键登录</h3><pre><code>- SKD初始化，调用 SDK 方法，参数 AppKey 和 AppSecret- 唤起授权页，授权页会显示手机号掩码以及运营商协议给用户确认- 同意授权并登录，客户端获取到token- 携带 token 调用服务一键登录</code></pre><h2 id="机智应对后端一次性返回10万条数据"><a href="#机智应对后端一次性返回10万条数据" class="headerlink" title="机智应对后端一次性返回10万条数据"></a>机智应对后端一次性返回10万条数据</h2><p>1、数据进行分组、分批、分堆<br>2、使用 <code>requestAnimationFrame</code> 代替 定时器<br>2、使用 <strong>数据分页</strong> 或 <strong>滚动触底加载</strong> 的思维<br>3、采用虚拟列表<br>4、启用多线程 <code>Web Worker</code> 处理代码逻辑</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试复习计划之TypeScript</title>
      <link href="/2022/10/01/interview/typescript/"/>
      <url>/2022/10/01/interview/typescript/</url>
      
        <content type="html"><![CDATA[<h2 id="实用技巧关键字"><a href="#实用技巧关键字" class="headerlink" title="实用技巧关键字"></a>实用技巧关键字</h2><p><strong>typeof</strong> 获取一个变量的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Data</span> = <span class="keyword">typeof</span> xx</span><br></pre></td></tr></table></figure><p><strong>keyof</strong> 用来取得一个对象接口的所有key值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span> | <span class="string">&quot;female&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//type PersonKey = &#x27;name&#x27;|&#x27;age&#x27;|&#x27;gender&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PersonKey</span> = keyof <span class="title class_">Person</span></span><br></pre></td></tr></table></figure><p><strong>in</strong> 去批量定义类型中的属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span> | <span class="string">&quot;female&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//批量把一个接口中的属性都变成可选的</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartPerson</span> = &#123;</span><br><span class="line">  [<span class="title class_">Key</span> <span class="keyword">in</span> keyof <span class="title class_">Person</span>]?: <span class="title class_">Person</span>[<span class="title class_">Key</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>abstract</strong> 抽象类</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类不能用来创建对象，只能专门用来被继承类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个抽象方法</span></span><br><span class="line">  <span class="comment">// 不需要方法体，子类继承后必须实现该抽象方法</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">say</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Aniaml</span>(<span class="string">&#x27;Mike&#x27;</span>) <span class="comment">// error</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Mike&#x27;</span>) <span class="comment">// success</span></span><br></pre></td></tr></table></figure><p><strong>implements</strong> 使类满足接口要求</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInter</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">say</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">MyInter</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>public protected private getter setter</strong> 类的属性修饰符</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 任意关系访问和修改</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 仅类及类的子类可访问修改</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">like</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 仅类内部访问和修改</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下边这种方式是定义加复制的简写</span></span><br><span class="line">  <span class="comment">// 等于 this.paramA = paramA</span></span><br><span class="line">  <span class="title function_">constrctor</span>(<span class="params"><span class="keyword">public</span> paramA: <span class="built_in">string</span>, <span class="keyword">protected</span> paramB: <span class="built_in">string</span>, <span class="keyword">private</span> paramC: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// new Person().name</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// new Person().name = &#x27;Mike&#x27;</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内置工具类型"><a href="#内置工具类型" class="headerlink" title="内置工具类型"></a>内置工具类型</h2><p><strong>Exclude&lt;T,U&gt;</strong> 从T可分配给的类型中排除U</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Exclude</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> E = <span class="title class_">Exclude</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">e</span>: E = <span class="number">10</span> <span class="comment">// 符合条件的只有number</span></span><br></pre></td></tr></table></figure><p><strong>Extract&lt;T,U&gt;</strong> 从T可分配给的类型中提取U</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Extract</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> E = <span class="title class_">Extract</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">e</span>: E = <span class="string">&quot;1&quot;</span> <span class="comment">// 符合条件的只有string</span></span><br></pre></td></tr></table></figure><p><strong>NonNullable<T></strong> 从T中排除null和undefined</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NonNullable</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="literal">null</span> | <span class="literal">undefined</span> ? <span class="built_in">never</span> : T</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> E = <span class="title class_">NonNullable</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">null</span> | <span class="literal">undefined</span>&gt;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">e</span>: E = <span class="number">1</span> <span class="comment">// 符合条件的只有 string | number</span></span><br></pre></td></tr></table></figure><p><strong>infer</strong> 声明一个类型变量并且对它进行使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; infer R ? R : <span class="built_in">any</span></span><br></pre></td></tr></table></figure><p><strong>ReturnType</strong> 表示在extends条件语句中待推断的类型变量</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...<span class="attr">args</span>: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUserInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&quot;hello&quot;</span>, <span class="attr">age</span>: <span class="number">10</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过 ReturnType 将 getUserInfo 的返回值类型赋给了 UserInfo</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> getUserInfo&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">userA</span>: <span class="title class_">UserInfo</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong> 获取函数类型的参数类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Parameters</span>&lt;T&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer R) =&gt; <span class="built_in">any</span> ? R : <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">Parameters</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Parameters</span>&lt;<span class="function">(<span class="params">s: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt; <span class="comment">// [string]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Parameters</span>&lt;&lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T&gt; <span class="comment">// [unknown]</span></span><br></pre></td></tr></table></figure><p><strong>Partial</strong> 将传入的属性由非可选变为可选</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]?: T[P] &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">a1</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">a2</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">a3</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> aPartial = <span class="title class_">Partial</span>&lt;A&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: aPartial = &#123;&#125; <span class="comment">// 不会报错</span></span><br></pre></td></tr></table></figure><p><strong>Required</strong> 将传入的属性中的可选项变为必选项</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Required</span>&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]-?: T[P] &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="string">&quot;male&quot;</span> | <span class="string">&quot;female&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">Required</span>&lt;<span class="title class_">Person</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Readonly</strong> 为传入的属性每一项都加上readonly修饰符来实现</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123; <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P] &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="string">&quot;male&quot;</span> | <span class="string">&quot;female&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">Readonly</span>&lt;<span class="title class_">Person</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">p.<span class="property">age</span> = <span class="number">11</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p><strong>Pick&lt;T,K&gt;</strong> 能够帮助我们从传入的属性中摘取某些返回</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从T中选择一组属性K</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Pick</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123; [P <span class="keyword">in</span> K]: T[P] &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Todo</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">description</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">done</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TodoBase</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">Todo</span>, <span class="string">&quot;title&quot;</span> | <span class="string">&quot;done&quot;</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TodoBase</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">done</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Record&lt;K,T&gt;</strong> K对应对象的key，T对应对象的value，返回的就是一个声明好的对象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Record</span>&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = <span class="string">&quot;x&quot;</span> | <span class="string">&quot;y&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PointList</span> = <span class="title class_">Record</span>&lt;<span class="title class_">Point</span>, &#123; <span class="attr">value</span>: <span class="built_in">number</span> &#125;&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">cars</span>: <span class="title class_">PointList</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: &#123; <span class="attr">value</span>: <span class="number">10</span> &#125;,</span><br><span class="line">  <span class="attr">y</span>: &#123; <span class="attr">value</span>: <span class="number">20</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Omit&lt;K,T&gt;</strong> 剔除k中T的属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Omit</span>=<span class="title class_">Pick</span>&lt;T,<span class="title class_">Exclude</span>&lt;keyof T,K&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">email</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserWithoutEmail</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">User</span>, <span class="string">&quot;email&quot;</span>&gt; <span class="comment">// UserWithoutEmail =&#123;id: string;name: string;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试复习计划之算法</title>
      <link href="/2022/01/01/interview/algorithm/"/>
      <url>/2022/01/01/interview/algorithm/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试复习计划之Vue</title>
      <link href="/2021/10/01/interview/vue/"/>
      <url>/2021/10/01/interview/vue/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-组件通信"><a href="#Vue-组件通信" class="headerlink" title="Vue 组件通信"></a>Vue 组件通信</h2><p>1、组件通信方式有以下8种：</p><ul><li>props</li><li>$emit&#x2F;<del>$on</del></li><li><del>$children</del>&#x2F;$parent</li><li>$attrs&#x2F;<del>$listeners</del></li><li>ref</li><li>$root</li><li>eventbus</li><li>vuex</li></ul><p>2、根据组件之间的关系讨论通信：</p><ul><li>父子组件<ul><li><code>ref</code>&#x2F;<code>props</code>&#x2F;<code>$attrs</code>&#x2F;<code>$emit</code>&#x2F;<code>$parent</code></li></ul></li><li>兄弟组件<ul><li><code>$parent</code>&#x2F;<code>$root</code>&#x2F;<code>enentbus</code>&#x2F;<code>vuex</code></li></ul></li><li>跨层级关系<ul><li><code>eventbus</code>&#x2F;<code>vuex</code>&#x2F;<code>provide+inject</code></li></ul></li></ul><h2 id="v-if-和-v-for-哪个优先级更高？"><a href="#v-if-和-v-for-哪个优先级更高？" class="headerlink" title="v-if 和 v-for 哪个优先级更高？"></a>v-if 和 v-for 哪个优先级更高？</h2><p>1、实践中不应该把 v-for 和 v-if 放一起<br>2、<strong>在 Vue2 中，v-for 的优先级是高于 v-if</strong>，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件，哪怕我们只渲染列表的一小部分元素，也得在每次重渲染的时候遍历整个列表，这会比较浪费；另外需要注意的是<strong>在 Vue3 中则完全相反，v-if 的优先级高于 v-for</strong>，所以 v-if 执行时，它调用的变量还不存在，就会导致异常。<br>3、在过滤列表中的目标时可以定义一个计算属性，先过滤好需要的列表再渲染。</p><h2 id="简述生命周期及各阶段做的事"><a href="#简述生命周期及各阶段做的事" class="headerlink" title="简述生命周期及各阶段做的事"></a>简述生命周期及各阶段做的事</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试复习计划之网络</title>
      <link href="/2020/10/01/interview/network/"/>
      <url>/2020/10/01/interview/network/</url>
      
        <content type="html"><![CDATA[<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://blog.haoji.me/https.html">HTTPS从认识到线上实战全记录</a></p><h2 id="SSL-x2F-TLS-amp-HTTPS"><a href="#SSL-x2F-TLS-amp-HTTPS" class="headerlink" title="SSL&#x2F;TLS &amp; HTTPS"></a>SSL&#x2F;TLS &amp; HTTPS</h2><ul><li>SSL协议用于对HTTP协议传输的数据进行加密</li><li>TLS是SSL的升级版</li><li>HTTPS具有信息加密、双向认证，有防窃听、防篡改、防冒充的优点</li></ul><h2 id="对称机密-x2F-非对称加密"><a href="#对称机密-x2F-非对称加密" class="headerlink" title="对称机密&#x2F;非对称加密"></a>对称机密&#x2F;非对称加密</h2><h2 id="客户端HTTPS与Web服务器通信时的步骤"><a href="#客户端HTTPS与Web服务器通信时的步骤" class="headerlink" title="客户端HTTPS与Web服务器通信时的步骤"></a>客户端HTTPS与Web服务器通信时的步骤</h2><ul><li>客户端使用 HTTPS URL 访问服务器，则要求 WEB 服务器建立 SSL 连接。</li><li>web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。</li><li>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。</li><li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li><li>web 服务器通过自己的私钥解密出会话密钥。</li><li>web 服务器通过会话密钥加密与客户端之间的通信。</li></ul><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p><ul><li>【你好，我想和你聊一聊？】第一次握手：建立连接时，客户端发送syn包（syn&#x3D;j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号。</li><li>【好的，我有空。】第二次握手：服务器收到syn包并确认客户的SYN（ack&#x3D;j+1），同时也发送一个自己的SYN包（syn&#x3D;k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>【好的，我们开始吧。】第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ul><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><ul><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li><li>服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ul><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><h2 id="浏览器的强制缓存-amp-amp-协商缓存"><a href="#浏览器的强制缓存-amp-amp-协商缓存" class="headerlink" title="浏览器的强制缓存 &amp;&amp; 协商缓存"></a>浏览器的强制缓存 &amp;&amp; 协商缓存</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试复习计划之浏览器</title>
      <link href="/2020/05/01/interview/browser/"/>
      <url>/2020/05/01/interview/browser/</url>
      
        <content type="html"><![CDATA[<h2 id="从输入URL到页面加载的全过程"><a href="#从输入URL到页面加载的全过程" class="headerlink" title="从输入URL到页面加载的全过程"></a>从输入URL到页面加载的全过程</h2><ul><li>域名解析(本地DNS -&gt; 根域服务器 -&gt; 顶级域服务器 -&gt; 所属域服务器 -&gt; 解析IP)<ul><li>向 本地DNS服务器(三大运营商) 发起域名解析请求</li><li>先查询其自身缓存纪录中是否存在对应的IP地址，有缓存直接返回缓存对应的IP地址信息</li><li>没有缓存进一步向 根域名服务器(包含13个顶级域名服务器) 发起求助</li><li>根域名服务器将告知本地服务器，该域名由.com顶级域名服务器管理，给出对应IP</li><li>该顶级域名服务器告知本地服务器，该域名需要向所属的域服务器上查询，给出对应IP</li><li>本地DNS服务器继续向 域服务器 发起域名解析请求，返回对应IP，并缓存域名对应IP地址对应关系记录</li></ul></li></ul><div align="left">    <img src=https://p3-sign.toutiaoimg.com/dfic-imagehandler/8d3c4969-bfc1-475b-9815-b059cb5d7b8f~noop.image?_iz=58558&from=article.pc_detail&x-expires=1678760076&x-signature=HcGdFcb7feKPbBMDsF6vQGDvOkM%3D width=200 height=200 /></div><h2 id="浏览器的工作原理"><a href="#浏览器的工作原理" class="headerlink" title="浏览器的工作原理"></a>浏览器的工作原理</h2><ul><li>渲染引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：渲染树。</li><li>渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</li><li>渲染树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 渲染引擎会遍历渲染树，由用户界面后端层将每个节点绘制出来。</li><li>这是一个渐进的过程。为达到更好的用户体验，渲染引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。</li></ul><h2 id="浏览器是如何渲染UI的？"><a href="#浏览器是如何渲染UI的？" class="headerlink" title="浏览器是如何渲染UI的？"></a>浏览器是如何渲染UI的？</h2><ul><li>浏览器获取HTML文件，然后对文件进行解析，形成DOM Tree;</li><li>与此同时，进行CSS解析，生成Style Rules;</li><li>接着将DOM Tree与Style Rules合成为 Render Tree;</li><li>接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标;</li><li>随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来;</li></ul><h2 id="DOM-Tree是如何构建的？"><a href="#DOM-Tree是如何构建的？" class="headerlink" title="DOM Tree是如何构建的？"></a>DOM Tree是如何构建的？</h2><ul><li>转码: 浏览器将接收到的二进制数据按照指定编码格式转化为HTML字符串</li><li>生成Tokens: 之后开始parser，浏览器会将HTML字符串解析成Tokens</li><li>构建Nodes: 对Node添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope</li><li>生成DOM Tree: 通过node包含的指针确定的关系构建出DOM Tree</li></ul><h2 id="浏览器重绘与重排的区别？"><a href="#浏览器重绘与重排的区别？" class="headerlink" title="浏览器重绘与重排的区别？"></a>浏览器重绘与重排的区别？</h2><ul><li>重排&#x2F;回流（Reflow）：当DOM的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素;</li><li>重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变;</li><li>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分;</li><li>重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘;</li><li>重绘不一定会出现重排，重排必然会出现重绘;</li></ul><h2 id="如何触发重排和重绘？"><a href="#如何触发重排和重绘？" class="headerlink" title="如何触发重排和重绘？"></a>如何触发重排和重绘？</h2><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p><ul><li>添加、删除、更新DOM节点;</li><li>通过display: none隐藏一个DOM节点-触发重排和重绘;</li><li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化;</li><li>移动或者给页面中的DOM节点添加动画;</li><li>添加一个样式表，调整样式属性;</li><li>用户行为，例如调整窗口大小，改变字号，或者滚动;</li></ul><h2 id="如何避免重绘或者重排？"><a href="#如何避免重绘或者重排？" class="headerlink" title="如何避免重绘或者重排？"></a>如何避免重绘或者重排？</h2><ul><li>集中改变样式，不要一条一条地修改 DOM 的样式。</li><li>不要把 DOM 结点的属性值放在循环里当成循环里的变量。</li><li>为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。</li><li>不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</li><li>尽量只修改position：absolute或fixed元素，对其他元素影响不大</li><li>动画开始GPU加速，translate使用3D变化</li><li>提升为合成层,将元素提升为合成层有以下优点：<ul><li><p>合成层的位图，会交由 GPU 合成，比 CPU 处理要快;</p></li><li><p>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层;</p></li><li><p>对于 transform 和 opacity 效果，不会触发 layout 和 paint;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 提升合成层的最好方式是使用 CSS 的 <span class="attribute">will-change</span> 属性： --&gt;</span><br><span class="line"><span class="selector-id">#target</span> &#123;</span><br><span class="line">    <span class="attribute">will-change</span>: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="JS垃圾回收机制"><a href="#JS垃圾回收机制" class="headerlink" title="JS垃圾回收机制"></a>JS垃圾回收机制</h2><ul><li>项目中，如果存在大量不被释放的内存（堆&#x2F;栈&#x2F;上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存;</li><li>浏览器垃圾回收机制&#x2F;内存回收机制: 浏览器的Javascript具有自动垃圾回收机制(GC:Garbage Collecation)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存;<ul><li>标记清除:在js中，最常用的垃圾回收机制是标记清除：当变量进入执行环境时，被标记为“进入环境”，当变量离开执行环境时，会被标记为“离开环境”。垃圾回收器会销毁那些带标记的值并回收它们所占用的内存空间;</li><li>谷歌浏览器：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收;</li><li>IE浏览器：“引用计数法”，当前内存被占用一次，计数累加1次，移除占用就减1，减到0时，浏览器就回收它;</li></ul></li><li>优化手段：内存优化 ; 手动释放：取消内存的占用即可;<ul><li>堆内存：fn &#x3D; null 【null：空指针对象】;</li><li>栈内存：把上下文中，被外部占用的堆的占用取消即可;</li></ul></li><li>内存泄漏<ul><li>在 JS 中，常见的内存泄露主要有 4 种,全局变量、闭包、DOM 元素的引用、定时器;</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试复习计划之JavaScript</title>
      <link href="/2020/01/01/interview/javascript/"/>
      <url>/2020/01/01/interview/javascript/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><ul><li>面向对象简而言之就是程序中所有的操作都是通过对象来完成。主要是对对象单词的理解，在计算机当中一种事物到了程序中就变成对象，一条狗就是一个事物。程序中所有的对象被分为两部分属性、方法，以一条狗为例，属性一只动物、性别公、毛色黑这是它的数据，它会叫这是它的功能，同样在程序中，数据是属性、功能是方法。</li><li>如何创建对象就要先定义类，可以理解为对象模型，Dog类创建狗的模型，不同的类用来创建不同的对象。</li></ul><h2 id="类、构造函数"><a href="#类、构造函数" class="headerlink" title="类、构造函数"></a>类、构造函数</h2><ul><li><p>类 class</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  name;</span><br><span class="line">  age;</span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>()</span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="keyword">new</span> <span class="title class_">Dog</span>()</span><br></pre></td></tr></table></figure></li><li><p>构造函数 constructor</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// this -&gt; dog dog1</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Mike&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Joi&#x27;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="new操作符的实例化过程"><a href="#new操作符的实例化过程" class="headerlink" title="new操作符的实例化过程"></a>new操作符的实例化过程</h2><ul><li><p>创建空对象</p></li><li><p>空对象隐式原型__proto__指向构造函数的原型</p></li><li><p>将空对象作为构造函数的上下文</p></li><li><p>判断构造函数返回值是否为对象，如果为对象就使用构造函数返回的值，否则使用 obj</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * new Create() 的过程，可以通过该函数来模拟</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params</span> &#123;<span class="type">Function</span>&#125; fn new操作符的目标函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params</span> &#123;<span class="type">Array</span>&#125; args 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// obj.__proto__ = fn.prototype</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, fn.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变构造函数指向 并 执行</span></span><br><span class="line">    <span class="keyword">let</span> result = fn.<span class="title function_">apply</span>(obj, args)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果构造函数返回值为对象则返回对象，否则返回 obj</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;BMW&#x27;</span>).<span class="property">name</span> <span class="comment">// &#x27;BMW&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;mercedes-benz&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;BMW&#x27;</span>).<span class="property">name</span> <span class="comment">// &#x27;mercedes-benz&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="作用域及作用域链"><a href="#作用域及作用域链" class="headerlink" title="作用域及作用域链"></a>作用域及作用域链</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li>当前创建函数或变量所处的上下文</li><li>ES6之前有全局作用域、函数作用域，现在又有了块级作用域</li><li>内部作用域可访问外部作用域，外部作用域访问不了内部作用域，起到隔离保护作用</li></ul><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><ul><li>变量取值，如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，查找过程形成的链条就叫做作用域链</li></ul><h2 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h2><h3 id="原型关系"><a href="#原型关系" class="headerlink" title="原型关系"></a>原型关系</h3><ul><li>每个 class都有显示原型 prototype</li><li>每个实例都有隐式原型 <strong>proto</strong></li><li>实例的 <strong>proto</strong> 指向对应 class 的 prototype</li></ul><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>函数的原型链对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针__proto__,该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用__proto__一直指向Object的原型对象上，而Object原型对象用Object.prototype.<strong>proto</strong> &#x3D; null表示原型链顶端。如此形成了js的原型链继承。同时所有的js对象都有Object的基本防范</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h2 id="JS中的数据类型及区别"><a href="#JS中的数据类型及区别" class="headerlink" title="JS中的数据类型及区别"></a>JS中的数据类型及区别</h2><h3 id="基本类型-值类型"><a href="#基本类型-值类型" class="headerlink" title="基本类型(值类型)"></a>基本类型(值类型)</h3><ul><li>Number(数字)、String(字符串)、Boolean(布尔)、null(空)、undefined(未定义)、Symbol(符号)、BigInt(精度整数)</li></ul><h3 id="引用类型-复杂数据类型"><a href="#引用类型-复杂数据类型" class="headerlink" title="引用类型(复杂数据类型)"></a>引用类型(复杂数据类型)</h3><ul><li>Object(对象)、Function(函数)、Array(数组)、Date(日期)、RegExp(正则表达式)、Global、Math(单体内置对象)</li></ul><h2 id="JS中的数据类型检测方案"><a href="#JS中的数据类型检测方案" class="headerlink" title="JS中的数据类型检测方案"></a>JS中的数据类型检测方案</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><ul><li>优点：可以区分基本类型</li><li>缺点：不能详细区分引用类型，<code>Null</code> 被认为 <code>Object</code> 类型</li></ul><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><ul><li>用于判断一个引用类型是否属于某构造函数</li><li>还可以在继承关系中用来判断一个实例是否属于它的父类型</li><li>优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象</li><li>缺点：Number，Boolean，String基本数据类型不能判断</li></ul><h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h3><ul><li>优点：精准判断任何数据类型</li></ul><h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><p>在块作用域内，let声明的变量只是<strong>创建时被提升</strong>，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// Cannot access &#x27;a&#x27; before initialization</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h2 id="JS-中-this-的情况"><a href="#JS-中-this-的情况" class="headerlink" title="JS 中 this 的情况"></a>JS 中 this 的情况</h2><ul><li>普通函数调用：通过函数名()直接调用：this指向全局对象window（注意let定义的变量不是window属性，只有window.xxx定义的才是。即let a &#x3D;’aaa’; this.a是undefined）</li><li>构造函数调用：函数作为构造函数，用new关键字调用时：this指向新new出的对象</li><li>对象函数调用：通过对象.函数名()调用的：this指向这个对象</li><li>箭头函数调用：箭头函数里面没有 this ，所以永远是上层作用域this（上下文）</li><li>apply和call调用：函数体内 this 的指向的是 call&#x2F;apply 方法第一个参数，若为空默认是指向全局对象window。</li><li>函数作为数组的一个元素，通过数组下标调用的：this指向这个数组</li><li>函数作为window内置函数的回调函数调用：this指向window（如setInterval setTimeout 等）</li></ul><h2 id="call-x2F-apply-x2F-bind-的区别"><a href="#call-x2F-apply-x2F-bind-的区别" class="headerlink" title="call&#x2F;apply&#x2F;bind 的区别"></a>call&#x2F;apply&#x2F;bind 的区别</h2><ul><li>fn.call(obj, 1, 2) 函数立即调用</li><li>fn.apply(obj, [1, 2]) 函数立即调用</li><li>fn.bind(obj, 1, 2) 返回对应函数</li></ul><h2 id="箭头函数的特性"><a href="#箭头函数的特性" class="headerlink" title="箭头函数的特性"></a>箭头函数的特性</h2><ul><li>没有自己的this，会捕获其所在的上下文的this值，作为自己的this值</li><li>没有constructor，是匿名函数，不能作为构造函数，不能通过new 调用</li><li>没有原型属性 Fn.prototype 值为 undefined</li><li>不能当做Generator函数,不能使用yield关键字</li></ul><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><ul><li>微任务：Promise回调 mutation回调</li><li>宏任务：DOM事件回调 Ajax回调 定时器回调</li></ul><h3 id="同步及异步执行循序"><a href="#同步及异步执行循序" class="headerlink" title="同步及异步执行循序"></a>同步及异步执行循序</h3><ul><li><p>代码自上而下执行</p></li><li><p>遇到同步代码，执行同步代码</p></li><li><p>遇到异步代码，将它的回调函数存到事件队列中</p></li><li><p>同步代码执行完，从事件队列中将异步回调函数按顺序执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>) <span class="comment">// 同步</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>), <span class="number">0</span>) <span class="comment">// 异步</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>) <span class="comment">// 同步</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： 1 3 2</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="异步在事件队列中的执行顺序"><a href="#异步在事件队列中的执行顺序" class="headerlink" title="异步在事件队列中的执行顺序"></a>异步在事件队列中的执行顺序</h3><ul><li><p>事件队列中先执行 微任务 再执行 宏任务</p></li><li><p>执行宏任务时，遇到微任务，就将它添加到微任务的任务队列中</p></li><li><p>宏任务执行完毕后，立即执行当前宏任务的微任务队列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>) <span class="comment">// 同步</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>) <span class="comment">// 异步：宏任务 setTimeout1</span></span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步：微任务 then1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>) <span class="comment">// 同步</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>) <span class="comment">// 同步</span></span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 异步：微任务 then2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>) <span class="comment">// 异步：宏任务 setTimeout2</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">8</span>) <span class="comment">// 同步</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1，4，5，8 6 2 3 7</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="模块化的理解"><a href="#模块化的理解" class="headerlink" title="模块化的理解"></a>模块化的理解</h2><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><ul><li>优点：通过对象的形式对变量进行包裹，避免命名冲突</li><li>缺点：定义的命名空间可以被外部任意修改</li></ul><h3 id="IIFE立即执行函数式"><a href="#IIFE立即执行函数式" class="headerlink" title="IIFE立即执行函数式"></a>IIFE立即执行函数式</h3><ul><li>函数内的变量不会造成全局污染</li><li>函数执行完后就会立即销毁，不会造成资源浪费</li><li>缺点：很难对模块进行拆分并完成相互通讯，不可复用</li></ul><h3 id="AMD-异步模块定义"><a href="#AMD-异步模块定义" class="headerlink" title="AMD 异步模块定义"></a>AMD 异步模块定义</h3><ul><li><p>它采用异步的方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在回调函数中，等到加载完成之后，这个回调函数才会运行。</p></li><li><p>引入模块需要用到 RequireJS</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 引入require.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 moduleA.js 导出</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&quot;module A&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 引入</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;moduleA&quot;</span>], <span class="keyword">function</span>(<span class="params">moduleA</span>)&#123;</span><br><span class="line">  moduleA.<span class="title function_">getName</span>()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="CMD-按需加载"><a href="#CMD-按需加载" class="headerlink" title="CMD 按需加载"></a>CMD 按需加载</h3><ul><li><p>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出</p></li><li><p>依赖就近，用的时候再require</p></li><li><p>相对于 AMD，对依赖模块的执行时机处理不同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> clock = <span class="built_in">require</span>(<span class="string">&#x27;clock&#x27;</span>);</span><br><span class="line">  clock.<span class="title function_">start</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="CJS"><a href="#CJS" class="headerlink" title="CJS"></a>CJS</h3><ul><li>CommonJs是Nodejs内置的同步加载的模块化机制</li><li>导出值为简单类型是复制，导出值为复杂类型是浅拷贝输出，模块会被缓存，可修改导出的值</li><li>可写在函数体中使用require引入</li><li>this是当前模块</li><li>运行时进行加载模块</li></ul><h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><ul><li>通用模块定义，兼容了CmmonJS和AMD规范</li><li>判断全局是否存在exports和define，如果存在exports，那么以CommonJS的方式暴露模块，如果存在define那么以AMD的方式暴露模块</li></ul><h3 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h3><ul><li>存在提升行为，会提升到整个模块的头部，首先执行</li><li>不允许修改引入的值，属于只读引用</li><li>编译时输出</li><li>对于动态 import().then 来说，原始值发生变化，import加载的值也会发生变化</li><li>this是undefined</li><li>浏览器加载 ESM，使用 <code>&lt;script&gt;</code> 标签，要加入 type&#x3D;”module” 属性</li><li>具有更好的可摇树性</li></ul><h2 id="JavaScript的设计模式"><a href="#JavaScript的设计模式" class="headerlink" title="JavaScript的设计模式"></a>JavaScript的设计模式</h2><h3 id="解决某个特定场景下对某种问题的解决方案"><a href="#解决某个特定场景下对某种问题的解决方案" class="headerlink" title="解决某个特定场景下对某种问题的解决方案"></a>解决某个特定场景下对某种问题的解决方案</h3><table><thead><tr><th>设计模式</th><th>特点</th><th>案例</th></tr></thead><tbody><tr><td>单例模式</td><td>只有一个实例可以全局访问</td><td>弹框组件（先创建再隐藏，需要时显示创建；对应模式只有一个实例）</td></tr><tr><td>策略模式</td><td>根据不同参数可以命中不同的策略</td><td>if else 根据不同参数做出处理</td></tr><tr><td>代理模式</td><td>代理对象和本体对象具有一致的接口</td><td>虚拟代理（图片预加载）；缓存代理（累积计算）</td></tr><tr><td>中介者模式</td><td>对象和对象之间借助第三方中介者进行通信</td><td>测试结束告知结果</td></tr><tr><td>装饰者模式</td><td>动态地给函数赋能</td><td>天冷了穿衣服，热了脱衣服</td></tr><tr><td>发布-订阅模式</td><td>事件发布&#x2F;订阅模式</td><td>微信小程序的 emit&#x2F;on 监听事件</td></tr><tr><td>观察者模式</td><td>当观察对象发生变化时自动调用相关函数</td><td>vue 双向绑定 Proxy</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试复习计划之Css</title>
      <link href="/2019/01/01/interview/css/"/>
      <url>/2019/01/01/interview/css/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML5-语义化标签"><a href="#HTML5-语义化标签" class="headerlink" title="HTML5 语义化标签"></a>HTML5 语义化标签</h2><ul><li><code>header</code> <code>nav</code> <code>main</code> <code>article</code> <code>section</code> <code>aside</code> <code>footer</code></li><li>代码结构清晰，易于阅读</li><li>利于开发和维护 方便其他设备解析（如屏幕阅读器）根据语义渲染网页</li><li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</li></ul><h2 id="HTML5-新特性"><a href="#HTML5-新特性" class="headerlink" title="HTML5 新特性"></a>HTML5 新特性</h2><ul><li>语义化标签</li><li>音视频处理API(audio,video)</li><li>canvas &#x2F; webGL</li><li>拖拽释放(Drag and drop) API</li><li>history API</li><li>requestAnimationFrame</li><li>地理位置(Geolocation)API</li><li>webSocket</li><li>web存储 localStorage、SessionStorage</li><li>表单控件，calendar、date、time、email、url、search</li></ul><h2 id="CSS-选择器及优先级"><a href="#CSS-选择器及优先级" class="headerlink" title="CSS 选择器及优先级"></a>CSS 选择器及优先级</h2><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ul><li>id选择器(#myid)</li><li>类选择器(.myclass)</li><li>属性选择器(a[rel&#x3D;”external”])</li><li>伪类选择器(a:hover, li:nth-child)</li><li>标签选择器(div, h1,p)</li><li>相邻选择器（h1 + p）</li><li>子选择器(ul &gt; li)</li><li>后代选择器(li a)</li><li>通配符选择器(*)</li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><code>!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</code></p><ul><li>!important</li><li>内联样式（1000）</li><li>ID选择器（0100）</li><li>类选择器&#x2F;属性选择器&#x2F;伪类选择器（0010）</li><li>元素选择器&#x2F;伪元素选择器（0001）</li><li>关系选择器&#x2F;通配符选择器（0000）</li></ul><h2 id="渐进增强与优雅降级的理解及区别"><a href="#渐进增强与优雅降级的理解及区别" class="headerlink" title="渐进增强与优雅降级的理解及区别"></a>渐进增强与优雅降级的理解及区别</h2><p><strong>渐进增强（Progressive Enhancement）：</strong> 一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</p><p><strong>优雅降级（Graceful Degradation）：</strong> 一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。 两者区别 1、广义： 其实要定义一个基准线，在此之上的增强叫做渐进增强，在此之下的兼容叫优雅降级 2、狭义： 渐进增强一般说的是使用CSS3技术，在不影响老浏览器的正常显示与使用情形下来增强体验，而优雅降级则是体现html标签的语义，以便在js&#x2F;css的加载失败&#x2F;被禁用时，也不影响用户的相应功能。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 例子 */</span></span><br><span class="line"><span class="selector-class">.transition</span> &#123; <span class="comment">/*渐进增强写法*/</span></span><br><span class="line">  -webkit-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">     -moz-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">       -o-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">          <span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.transition</span> &#123; <span class="comment">/*优雅降级写法*/</span></span><br><span class="line">          <span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">       -o-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">     -moz-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">  -webkit-<span class="attribute">transition</span>: all .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h2><p>过渡<code>transition</code>、动画<code>animation</code>、形状转换<code>transform</code>、选择器<code>nth-of-type()</code>、阴影、边框、背景、文字、渐变、Filter（滤镜）、弹性布局、栅格布局、多列布局、媒体查询</p><h2 id="position-属性的值有哪些及其区别"><a href="#position-属性的值有哪些及其区别" class="headerlink" title="position 属性的值有哪些及其区别"></a>position 属性的值有哪些及其区别</h2><ul><li>固定定位 fixed： 元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定 位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重叠。</li><li>相对定位 relative： 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直 或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是 否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</li><li>绝对定位 absolute： 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那 么它的位置相对于。absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。</li><li>粘性定位 sticky： 元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定 位，之后为固定定位。</li><li>默认定位 Static： 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声 明）。 inherit: 规定应该从父元素继承 position 属性的值。</li></ul><h2 id="box-sizing属性"><a href="#box-sizing属性" class="headerlink" title="box-sizing属性"></a>box-sizing属性</h2><ul><li>box-sizing 规定两个并排的带边框的框，语法为 box-sizing：content-box&#x2F;border-box&#x2F;inherit</li><li>content-box：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框。【标准盒子模型】</li><li>border-box：为元素设定的宽度和高度决定了元素的边框盒。【IE 盒子模型】</li><li>inherit：继承父元素的 box-sizing 值</li></ul><h2 id="CSS-盒子模型"><a href="#CSS-盒子模型" class="headerlink" title="CSS 盒子模型"></a>CSS 盒子模型</h2><p>CSS 盒模型本质上是一个盒子，它包括：边距，边框，填充和实际内容。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。</p><ul><li>在标准的盒子模型中，width 指 content 部分的宽度。</li><li>在 IE 盒子模型中，width 表示 content+padding+border 这三个部分的宽度。</li><li>标准盒模型： 一个块的总宽度 &#x3D; width+margin(左右)+padding(左右)+border(左右)</li><li>怪异盒模型： 一个块的总宽度 &#x3D; width+margin（左右）（既 width 已经包含了 padding 和 border 值）</li></ul><h2 id="BFC（块级格式上下文）"><a href="#BFC（块级格式上下文）" class="headerlink" title="BFC（块级格式上下文）"></a>BFC（块级格式上下文）</h2><p>BFC 是 Block Formatting Context 的缩写，即块级格式化上下文。BFC是CSS布局的一个概念，是一个独立的渲染区域，规定了内部box如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC 的高度的时候，浮动元素也参与计算。</p><h3 id="BFC的原理布局规则"><a href="#BFC的原理布局规则" class="headerlink" title="BFC的原理布局规则"></a>BFC的原理布局规则</h3><ul><li>内部的Box会在垂直方向，一个接一个地放置</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反</li><li>BFC的区域不会与float box重叠</li><li>BFC是一个独立容器，容器里面的子元素不会影响到外面的元素</li><li>计算BFC的高度时，浮动元素也参与计算高度</li><li>元素的类型和display属性，决定了这个Box的类型。不同类型的Box会参与不同的Formatting Context</li></ul><h3 id="如何创建BFC"><a href="#如何创建BFC" class="headerlink" title="如何创建BFC"></a>如何创建BFC</h3><ul><li>根元素，即HTML元素</li><li>float的值不为none</li><li>position为absolute或fixed</li><li>display的值为inline-block、table-cell、table-caption</li><li>overflow的值不为visible</li></ul><h3 id="BFC的使用场景"><a href="#BFC的使用场景" class="headerlink" title="BFC的使用场景"></a>BFC的使用场景</h3><ul><li>去除边距重叠现象</li><li>清除浮动（让父元素的高度包含子浮动元素）</li><li>避免某元素被浮动元素覆盖</li><li>避免多列布局由于宽度计算四舍五入而自动换行</li></ul><h2 id="让一个元素水平垂直居中"><a href="#让一个元素水平垂直居中" class="headerlink" title="让一个元素水平垂直居中"></a>让一个元素水平垂直居中</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ul><li><p>对于 行内元素 : text-align: center;</p></li><li><p>对于确定宽度的块级元素：</p><ul><li>width和margin实现。margin: 0 auto;</li><li>绝对定位和margin-left: margin-left: (父width - 子width）&#x2F;2, 前提是父元素position: relative</li></ul></li><li><p>对于宽度未知的块级元素</p><ul><li>table标签配合margin左右auto实现水平居中。使用table标签（或直接将块级元素设值为 display:table），再通过给该标签添加左右margin为auto。</li><li>inline-block实现水平居中方法。display：inline-block和text-align:center实现水平居中。</li><li>绝对定位+transform，translateX可以移动本身元素的50%。</li><li>flex布局使用justify-content:center</li></ul></li></ul><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ul><li>利用 line-height 实现居中，这种方法适合纯文字类</li><li>通过设置父容器 相对定位 ，子级设置 绝对定位，标签通过margin实现自适应居中</li><li>弹性布局 flex :父级设置display: flex; 子级设置margin为auto实现自适应居中</li><li>父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现</li><li>table 布局，父级通过转换成表格形式，然后子级设置 vertical-align 实现。（需要注意的是：vertical-align: middle使用的前提条件是内联元素以及display值为table-cell的元素）。</li></ul><h2 id="用CSS实现三角符号"><a href="#用CSS实现三角符号" class="headerlink" title="用CSS实现三角符号"></a>用CSS实现三角符号</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记忆口诀：盒子宽高均为零，三面边框皆透明。 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">100px</span> solid <span class="number">#ff0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><ul><li>Flex 布局</li><li>Rem 布局</li><li>百分比布局</li><li>浮动布局</li></ul><h2 id="如何使用rem或viewport进行移动端适配"><a href="#如何使用rem或viewport进行移动端适配" class="headerlink" title="如何使用rem或viewport进行移动端适配"></a>如何使用rem或viewport进行移动端适配</h2><p><strong>rem适配原理：</strong>改变了一个元素在不同设备上占据的css像素的个数。</p><ul><li>优点：没有破坏完美视口</li><li>缺点：px值转换rem太过于复杂(下面我们使用less来解决这个问题)</li></ul><p><strong>viewport适配的原理：</strong>每一个元素在不同设备上占据的css像素的个数是一样的。但是css像素和物理像素的比例是不一样的，等比的。</p><ul><li>在我们设计图上所量取的大小即为我们可以设置的像素大小，即所量即所设</li><li>缺点破坏完美视口</li></ul><h2 id="清除浮动的方式"><a href="#清除浮动的方式" class="headerlink" title="清除浮动的方式"></a>清除浮动的方式</h2><ul><li>父级添加overflow属性，或者设置高度</li><li>添加额外标签</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    //添加额外标签并且添加clear属性</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear:both&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    //也可以加一个br标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>建立伪类选择器清除浮动</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//在css中添加<span class="selector-pseudo">:after</span>伪元素</span><br><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="comment">/* 设置添加子元素的内容是空 */</span></span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">/* 设置添加子元素为块级元素 */</span></span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="comment">/* 设置添加的子元素的高度0 */</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 设置添加子元素看不见 */</span></span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">    <span class="comment">/* 设置clear：both */</span></span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
